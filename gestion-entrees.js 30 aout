class GestionEntrees {
    constructor() {
        this.prestations = [];
        this.selectedDayFilter = null;
        this.isPreviewActive = false;
        this.draggedItem = null;
        this.draggedPure = null;
        this.editingPrestationId = null;
        this.token = localStorage.getItem('token');
        this.apiBaseUrl = '/api/entrees';
        
        // Initialisation des éléments DOM
        this.initializeElements();
    }

    initializeElements() {
        // Conteneurs principaux
        this.accessList = document.getElementById('access-prestations-list');
        this.pureList = document.getElementById('pure-prestations-list');
        this.separatorLine = document.getElementById('separator-line');
        this.previewSection = document.getElementById('preview-section');
        this.accessForm = document.getElementById('access-form');
        this.pureContainer = document.getElementById('pure-container');
        
        // Boutons
        this.saveBtn = document.querySelector('.save-btn');
        this.previewBtn = document.querySelector('.preview-btn');
        
        // Champs de formulaire
        this.daysCheckboxes = document.getElementById('days-checkboxes');
        this.accessPresentationLow = document.getElementById('access-presentation-low');
        this.accessPresentationNormal = document.getElementById('access-presentation-normal');
        this.accessPresentationAlcohol = document.getElementById('access-presentation-alcohol');
        this.accessPresentationSoft = document.getElementById('access-presentation-soft');
        this.accessPrice = document.getElementById('access-price');
        this.accessSex = document.getElementById('access-sex');
    }

    async init() {
        await this.loadData();
        this.bindEvents();
        this.addPure();
        this.renderPrestations();
        this.setupTooltips();
    }

    // --- MÉTHODES DE CHARGEMENT ET SAUVEGARDE ---

    async loadData() {
        if (!this.token) {
            console.warn('Aucun token disponible');
            return;
        }

        try {
            const response = await fetch(this.apiBaseUrl, {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${this.token}`,
                    'Content-Type': 'application/json'
                }
            });

            if (!response.ok) {
                throw new Error(`Erreur HTTP: ${response.status}`);
            }

            const data = await response.json();
            this.prestations = Array.isArray(data) ? data : [];
            this.renderPrestations();
        } catch (error) {
            console.error('Erreur lors du chargement des données:', error);
            this.showMessage('Erreur lors du chargement des prestations', 'error');
        }
    }

    async saveData(prestation) {
        if (!this.token) {
            this.showMessage('Token manquant', 'error');
            return false;
        }

        try {
            this.showLoading(true);

         console.log('Données envoyées à l\'API:', JSON.stringify(prestation, null, 2));   

            const response = await fetch(this.apiBaseUrl, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${this.token}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(prestation)
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.message || `Erreur HTTP: ${response.status}`);
            }

            const result = await response.json();
            this.showMessage('Prestation enregistrée avec succès', 'success');
            await this.loadData(); // Recharger les données
            return true;
        } catch (error) {
            console.error('Erreur lors de la sauvegarde:', error);
            this.showMessage(`Erreur: ${error.message}`, 'error');
            return false;
        } finally {
            this.showLoading(false);
        }
    }

   async updateData(id, prestation) { // AJOUTER : Nouvelle fonction pour la MISE A JOUR
        if (!this.token) {
            this.showMessage('Token manquant', 'error');
            return false;
        }

        try {
            this.showLoading(true);
            const response = await fetch(`${this.apiBaseUrl}/${id}`, { // Utilise l'ID dans l'URL
                method: 'PUT', // Méthode PUT pour la mise à jour
                headers: {
                    'Authorization': `Bearer ${this.token}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(prestation)
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.message || `Erreur HTTP: ${response.status}`);
            }

            this.showMessage('Prestation mise à jour avec succès', 'success');
            await this.loadData();
            return true;
        } catch (error) {
            console.error('Erreur lors de la mise à jour:', error);
            this.showMessage(`Erreur: ${error.message}`, 'error');
            return false;
        } finally {
            this.showLoading(false);
        }
    } 

    async deleteData(index) {
        if (!this.token || !this.prestations[index]) {
            return false;
        }

        const prestation = this.prestations[index];
        if (!prestation.id) {
            // Si pas d'ID, suppression locale uniquement
            this.prestations.splice(index, 1);
            this.renderPrestations();
            return true;
        }

        try {
            this.showLoading(true);

            const response = await fetch(`${this.apiBaseUrl}/${prestation.id}`, {
                method: 'DELETE',
                headers: {
                    'Authorization': `Bearer ${this.token}`,
                    'Content-Type': 'application/json'
                }
            });

            if (!response.ok) {
                throw new Error(`Erreur HTTP: ${response.status}`);
            }

            this.showMessage('Prestation supprimée avec succès', 'success');
            await this.loadData();
            return true;
        } catch (error) {
            console.error('Erreur lors de la suppression:', error);
            this.showMessage(`Erreur: ${error.message}`, 'error');
            return false;
        } finally {
            this.showLoading(false);
        }
    }

    // --- GESTION DES ÉVÉNEMENTS ---

    bindEvents() {
        // Bouton de sauvegarde
        if (this.saveBtn) {
            this.saveBtn.addEventListener('click', () => this.savePrestation());
        }

        // Boutons de filtre par jour
        document.querySelectorAll('.day-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const day = e.target.textContent.trim();
                this.filterByDay(day);
            });
        });

        // Bouton d'aperçu
        if (this.previewBtn) {
            this.previewBtn.addEventListener('click', () => this.showPreview());
        }

        // Bouton d'ajout de formule bouteille
        const addPureBtn = document.querySelector('.add-pure-btn');
        if (addPureBtn) {
            addPureBtn.addEventListener('click', () => this.addPure());
        }

        // Cacher l'éditeur si clic en dehors
        document.addEventListener('click', (e) => {
            const editors = document.querySelectorAll('.max-entries-editor');
            editors.forEach(editor => {
                if (!editor.contains(e.target) && 
                    !editor.parentElement.querySelector('.pure-max-entries').contains(e.target)) {
                    editor.style.display = 'none';
                }
            });
        });
    }

    // --- GESTION DES FORMULES BOUTEILLE ---

    addPure() {
        const pureDiv = document.createElement('div');
        pureDiv.className = 'pure-row';
        pureDiv.innerHTML = `
            <div class="category-section">
                <div>
                    <label>Catégorie de bouteille (optionnel)</label>
                    <input type="text" list="bottle-categories" placeholder="Saisir ou sélectionner une catégorie" class="pure-category-input">
                    <datalist id="bottle-categories">
                        <option value="VODKA">
                        <option value="WHISKY">
                        <option value="RUM">
                        <option value="JÄGERBOMB">
                        <option value="CHAMPAGNE">
                    </datalist>
                </div>
            </div>
            <div class="name-section">
                <div>
                    <label>Nom</label>
                    <input type="text" placeholder="Ex: Bouteille" class="pure-name">
                </div>
                <div>
                    <label>Qt. bouteilles</label>
                    <input type="number" min="1" placeholder="Quantité" class="pure-qty">
                </div>
                <div>
                    <label>Prix</label>
                    <input type="number" step="0.01" min="0" placeholder="Prix (€)" class="pure-price">
                </div>
                <div>
                    <label>Max. Entrée</label>
                    <input type="text" placeholder="Cliquez pour définir" class="pure-max-entries" readonly>
                </div>
                <div>
                    <label>Réduc. bouteille suppl.</label>
                    <input type="number" step="0.01" min="0" placeholder="Réduction (€)" class="pure-discount">
                </div>
                <button type="button" class="pure-duplicate-btn" aria-label="Dupliquer la formule">📋</button>
                <button type="button" class="pure-delete-btn" aria-label="Supprimer la formule">🗑️</button>
            </div>
            <div class="details-section">
                <button type="button" class="add-details-btn" aria-label="Ajouter des détails">+</button>
            </div>
        `;

        this.pureContainer.appendChild(pureDiv);
        this.bindPureEvents(pureDiv);
        this.addDragEvents(pureDiv);
    }

    bindPureEvents(pureDiv) {
        // Bouton de duplication
        const duplicateBtn = pureDiv.querySelector('.pure-duplicate-btn');
        duplicateBtn.addEventListener('click', () => this.duplicatePure(duplicateBtn));

        // Bouton de suppression
        const deleteBtn = pureDiv.querySelector('.pure-delete-btn');
        deleteBtn.addEventListener('click', () => this.deletePure(deleteBtn));

        // Bouton d'ajout de détails
        const addDetailsBtn = pureDiv.querySelector('.add-details-btn');
        addDetailsBtn.addEventListener('click', () => this.addDetails(addDetailsBtn));

        // Champ Max. Entrée
        const maxEntriesInput = pureDiv.querySelector('.pure-max-entries');
        maxEntriesInput.addEventListener('click', () => this.showMaxEntriesEditor(maxEntriesInput));
    }

    duplicatePure(button) {
        const originalRow = button.closest('.pure-row');
        const newRow = originalRow.cloneNode(true);
        
        // Réinitialiser les événements
        this.bindPureEvents(newRow);
        this.addDragEvents(newRow);
        
        this.pureContainer.appendChild(newRow);
    }

    deletePure(button) {
        const row = button.closest('.pure-row');
        row.remove();
        
        // Assurer qu'il y a au moins une ligne
        if (this.pureContainer.children.length === 0) {
            this.addPure();
        }
    }

    addDetails(button) {
        const detailsSection = button.parentElement;
        const pureRow = detailsSection.parentElement;
        const nameSection = pureRow.querySelector('.name-section');
        const lastDetailsRow = detailsSection.querySelector('.details-row:last-child') || nameSection;

        const newDetailsRow = document.createElement('div');
        newDetailsRow.className = 'details-row';

        // Copier les valeurs de la dernière ligne
        const sourceMaxEntries = lastDetailsRow.querySelector('.pure-max-entries')?.dataset.maxEntries || JSON.stringify({ 1: 1 });

        newDetailsRow.innerHTML = `
            <div>
                <label>Nom</label>
                <input type="text" value="${this.sanitizeInput(lastDetailsRow.querySelector('.pure-name')?.value || '')}" class="pure-name">
            </div>
            <div>
                <label>Qt. bouteilles</label>
                <input type="number" min="1" value="${lastDetailsRow.querySelector('.pure-qty')?.value || ''}" class="pure-qty">
            </div>
            <div>
                <label>Prix</label>
                <input type="number" step="0.01" min="0" value="${lastDetailsRow.querySelector('.pure-price')?.value || ''}" class="pure-price">
            </div>
            <div>
                <label>Max. Entrée</label>
                <input type="text" placeholder="Cliquez pour définir" class="pure-max-entries" readonly 
                       data-max-entries='${sourceMaxEntries}'>
            </div>
            <div>
                <label>Réduc. bouteille suppl.</label>
                <input type="number" step="0.01" min="0" value="${lastDetailsRow.querySelector('.pure-discount')?.value || ''}" class="pure-discount">
            </div>
            <button type="button" class="delete-details-btn" aria-label="Supprimer les détails">🗑️</button>
        `;

        detailsSection.insertBefore(newDetailsRow, button);

        // Événements
        const maxEntriesInput = newDetailsRow.querySelector('.pure-max-entries');
        maxEntriesInput.addEventListener('click', () => this.showMaxEntriesEditor(maxEntriesInput));
        
        const deleteBtn = newDetailsRow.querySelector('.delete-details-btn');
        deleteBtn.addEventListener('click', () => this.deleteDetails(deleteBtn));

        // Configurer la valeur du champ Max. Entrée
        const sourceMaxInput = lastDetailsRow.querySelector('.pure-max-entries');
        if (sourceMaxInput && sourceMaxInput.dataset.maxEntries) {
            maxEntriesInput.value = sourceMaxInput.value || 'Cliquez pour définir';
        } else {
            maxEntriesInput.value = '1=1';
        }
    }

    deleteDetails(button) {
        button.closest('.details-row').remove();
    }

    // --- GESTION DE L'ÉDITEUR MAX ENTRÉES ---

    showMaxEntriesEditor(input) {
        let editor = input.parentElement.querySelector('.max-entries-editor');
        
        if (!editor) {
            editor = document.createElement('div');
            editor.className = 'max-entries-editor';
            editor.innerHTML = `
                <label>Définir Max. Entrée par Qt. bouteilles:</label>
                <div id="max-entries-inputs">
                    <div class="max-entry-row">1 bouteille: <input type="number" min="1" class="max-entry-input" data-qty="1"></div>
                    <div class="max-entry-row">2 bouteilles: <input type="number" min="1" class="max-entry-input" data-qty="2"></div>
                </div>
                <div class="editor-buttons">
                    <button type="button" class="add-max-btn">+ Ajouter</button>
                    <button type="button" class="save-max-btn">OK</button>
                </div>
            `;
            
            input.parentElement.appendChild(editor);
            this.positionEditor(editor, input);
            
            // Événements
            editor.querySelector('.add-max-btn').addEventListener('click', () => this.addMaxEntryInput(editor));
            editor.querySelector('.save-max-btn').addEventListener('click', () => this.saveMaxEntries(editor));

            // Charger les données existantes
            if (input.dataset.maxEntries) {
                try {
                    const maxEntries = JSON.parse(input.dataset.maxEntries);
                    const inputsContainer = editor.querySelector('#max-entries-inputs');
                    inputsContainer.innerHTML = '';
                    
                    for (const [qty, max] of Object.entries(maxEntries)) {
                        const div = document.createElement('div');
                        div.className = 'max-entry-row';
                        div.innerHTML = `${qty} bouteilles: <input type="number" min="1" class="max-entry-input" data-qty="${qty}" value="${max}">`;
                        inputsContainer.appendChild(div);
                    }
                } catch (error) {
                    console.error('Erreur lors du parsing des max entries:', error);
                }
            }
        }
        
        editor.style.display = editor.style.display === 'none' ? 'block' : 'none';
    }

    positionEditor(editor, input) {
    // Le parent qui a "position: relative"
    const parentContainer = input.offsetParent;

    if (!parentContainer) {
        console.error("Le conteneur parent relatif est introuvable. Assurez-vous que le CSS est correct.");
        return;
    }

    // Obtenir les positions par rapport à la fenêtre (viewport)
    const inputRect = input.getBoundingClientRect();
    const parentRect = parentContainer.getBoundingClientRect();

    // Calculer la position de l'éditeur PAR RAPPORT au parent relatif
    // top: position du bas de l'input - position du haut du parent + un petit espace
    const topPosition = inputRect.bottom - parentRect.top + 5; 
    
    // left: position de gauche de l'input - position de gauche du parent
    const leftPosition = inputRect.left - parentRect.left;

    // Appliquer les styles
    editor.style.position = 'absolute';
    editor.style.top = `${topPosition}px`;
    editor.style.left = `${leftPosition}px`;
    editor.style.zIndex = '1001'; // Un z-index un peu plus élevé pour être sûr

    // --- Vérification pour ne pas sortir de l'écran (bonus) ---
    // Cette partie s'assure que si l'éditeur est trop bas, il se place au-dessus
    setTimeout(() => {
        const editorRect = editor.getBoundingClientRect();
        if (editorRect.bottom > window.innerHeight) {
            // Se positionner au-dessus de l'input au lieu d'en-dessous
            const topPositionAbove = inputRect.top - parentRect.top - editorRect.height - 5;
            editor.style.top = `${topPositionAbove}px`;
        }
    }, 0);
}

    addMaxEntryInput(editor) {
        const inputsContainer = editor.querySelector('#max-entries-inputs');
        const existingQtys = Array.from(inputsContainer.querySelectorAll('.max-entry-input'))
            .map(input => parseInt(input.dataset.qty));
        const nextQty = Math.max(...existingQtys, 0) + 1;
        
        const div = document.createElement('div');
        div.className = 'max-entry-row';
        div.innerHTML = `${nextQty} bouteilles: <input type="number" min="1" class="max-entry-input" data-qty="${nextQty}">`;
        inputsContainer.appendChild(div);
    }

    saveMaxEntries(editor) {
        const inputs = editor.querySelectorAll('.max-entry-input');
        const maxEntries = {};
        
        inputs.forEach(input => {
            const value = parseInt(input.value);
            if (!isNaN(value) && value >= 1) {
                maxEntries[input.dataset.qty] = value;
            }
        });

        const inputField = editor.parentElement.querySelector('.pure-max-entries');
        
        try {
            inputField.dataset.maxEntries = JSON.stringify(maxEntries);
            
            if (Object.keys(maxEntries).length > 0) {
                inputField.value = Object.entries(maxEntries)
                    .map(([qty, max]) => `${qty}=${max}`)
                    .join(', ');
            } else {
                inputField.value = 'Cliquez pour définir';
            }
        } catch (error) {
            console.error('Erreur lors de la sauvegarde des max entries:', error);
            inputField.value = 'Erreur – Cliquez pour définir';
        }
        
        editor.style.display = 'none';
    }

    // --- DRAG AND DROP ---

    addDragEvents(element) {
        element.addEventListener('dragstart', (e) => this.handleDragStart(e, element));
        element.addEventListener('dragover', (e) => this.handleDragOver(e));
        element.addEventListener('drop', (e) => this.handleDrop(e, element));
        element.addEventListener('dragend', (e) => this.handleDragEnd(e, element));
    }

    handleDragStart(e, element) {
        this.draggedItem = element;
        element.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/html', element.innerHTML);
    }

    handleDragOver(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
    }

    handleDrop(e, element) {
        e.preventDefault();
        
        if (this.draggedItem !== element && this.draggedItem) {
            const container = element.parentElement;
            const allItems = Array.from(container.children);
            const draggedIndex = allItems.indexOf(this.draggedItem);
            const droppedIndex = allItems.indexOf(element);
            
            if (draggedIndex !== -1 && droppedIndex !== -1) {
                const [movedItem] = allItems.splice(draggedIndex, 1);
                allItems.splice(droppedIndex, 0, movedItem);
                
                container.innerHTML = '';
                allItems.forEach(item => {
                    container.appendChild(item);
                    if (item.classList.contains('pure-row')) {
                        this.bindPureEvents(item);
                        this.addDragEvents(item);
                    }
                });
            }
        }
    }

    handleDragEnd(e, element) {
        element.classList.remove('dragging');
        this.draggedItem = null;
    }

    // --- VALIDATION ---

    validateAccessSoiree() {
        const presentationLow = this.accessPresentationLow;
        const presentationNormal = this.accessPresentationNormal;
        const presentationAlcohol = this.accessPresentationAlcohol;
        const presentationSoft = this.accessPresentationSoft;
        const price = this.accessPrice;

        // Supprimer les classes d'erreur existantes
        [presentationLow, presentationNormal, presentationAlcohol, presentationSoft, price]
            .forEach(el => el && el.classList.remove('error'));

        const hasPresentation = presentationLow.value.trim() || 
                               presentationNormal.value.trim() || 
                               presentationAlcohol.value.trim() || 
                               presentationSoft.value.trim();
        const hasPrice = price.value !== '';

        let errors = [];

        if (hasPresentation && !hasPrice) {
            errors.push('Veuillez remplir le champ "Prix" dans "Les entrées" si une présentation est indiquée.');
            price.classList.add('error');
        }

        if (hasPrice && !hasPresentation) {
            errors.push('Veuillez remplir au moins une "Présentation" dans "Les entrées" si un prix est indiqué.');
            [presentationLow, presentationNormal, presentationAlcohol, presentationSoft]
                .forEach(el => el.classList.add('error'));
        }

        return { 
            isValid: hasPresentation && hasPrice, 
            errors 
        };
    }

    validatePureSoiree() {
        const pureRows = document.querySelectorAll('.pure-row');
        let errors = [];
        let hasValidRow = false;

        pureRows.forEach((row, index) => {
            const name = row.querySelector('.name-section .pure-name');
            const qty = row.querySelector('.name-section .pure-qty');
            const price = row.querySelector('.name-section .pure-price');
            const maxEntries = row.querySelector('.name-section .pure-max-entries');

            // Supprimer les classes d'erreur
            [name, qty, price, maxEntries].forEach(el => el && el.classList.remove('error'));

            const additionalDetails = row.querySelectorAll('.details-section .details-row');
            additionalDetails.forEach(detailRow => {
                detailRow.querySelectorAll('input').forEach(input => input.classList.remove('error'));
            });

            // Vérifier si la ligne principale est valide
            const isRowValid = name.value.trim() && 
                              qty.value && 
                              price.value && 
                              (maxEntries.dataset.maxEntries && maxEntries.dataset.maxEntries !== '{}');

            if (isRowValid) {
                hasValidRow = true;

                // Valider les détails supplémentaires
                additionalDetails.forEach((detailRow, detailIndex) => {
                    const nameDetail = detailRow.querySelector('.pure-name');
                    const qtyDetail = detailRow.querySelector('.pure-qty');
                    const priceDetail = detailRow.querySelector('.pure-price');
                    const maxEntriesDetail = detailRow.querySelector('.pure-max-entries');

                    if (!nameDetail.value.trim()) {
                        errors.push(`Veuillez remplir le champ "Nom" dans la ligne supplémentaire ${detailIndex + 1} de la ligne ${index + 1}.`);
                        nameDetail.classList.add('error');
                    }
                    if (!qtyDetail.value) {
                        errors.push(`Veuillez remplir le champ "Qt. bouteilles" dans la ligne supplémentaire ${detailIndex + 1} de la ligne ${index + 1}.`);
                        qtyDetail.classList.add('error');
                    }
                    if (!priceDetail.value) {
                        errors.push(`Veuillez remplir le champ "Prix" dans la ligne supplémentaire ${detailIndex + 1} de la ligne ${index + 1}.`);
                        priceDetail.classList.add('error');
                    }
                    if (!maxEntriesDetail.dataset.maxEntries || maxEntriesDetail.dataset.maxEntries === '{}') {
                        errors.push(`Veuillez définir "Max. Entrée" dans la ligne supplémentaire ${detailIndex + 1} de la ligne ${index + 1}.`);
                        maxEntriesDetail.classList.add('error');
                    }
                });
            } else if (name.value.trim() || qty.value || price.value || 
                      (maxEntries.dataset.maxEntries && maxEntries.dataset.maxEntries !== '{}')) {
                // Ligne partiellement remplie
                if (!name.value.trim()) {
                    errors.push(`Veuillez remplir le champ "Nom" dans la ligne ${index + 1}.`);
                    name.classList.add('error');
                }
                if (!qty.value) {
                    errors.push(`Veuillez remplir le champ "Qt. bouteilles" dans la ligne ${index + 1}.`);
                    qty.classList.add('error');
                }
                if (!price.value) {
                    errors.push(`Veuillez remplir le champ "Prix" dans la ligne ${index + 1}.`);
                    price.classList.add('error');
                }
                if (!maxEntries.dataset.maxEntries || maxEntries.dataset.maxEntries === '{}') {
                    errors.push(`Veuillez définir "Max. Entrée" dans la ligne ${index + 1}.`);
                    maxEntries.classList.add('error');
                }
            }
        });

        return { errors, hasValidRow };
    }

    // --- SAUVEGARDE ---

    async savePrestation() {
         if (!confirm('Souhaitez-vous enregistrer les modifications ?')) {
        return;
    }

    // CORRECTION ICI - Construire correctement le tableau
    const daysCheckboxes = document.querySelectorAll('input[name="days"]:checked');
    const days = Array.from(daysCheckboxes).map(checkbox => checkbox.value);
    
    console.log('Days avant envoi:', days); // Pour déboguer
    
    let errors = [];

    // Validation des jours
    this.daysCheckboxes.classList.remove('error');
    if (days.length === 0) {
        errors.push('Veuillez sélectionner au moins un jour.');
        this.daysCheckboxes.classList.add('error');
    }

        // Validation des sections
        const accessValidation = this.validateAccessSoiree();
        errors = [...errors, ...accessValidation.errors];

        const { errors: pureErrors, hasValidRow: isPureValid } = this.validatePureSoiree();
        errors = [...errors, ...pureErrors];

        // Vérifier qu'au moins une section est complète
        if (!accessValidation.isValid && !isPureValid) {
            errors.push('Veuillez remplir au moins une section complète : "Les entrées" ou "Les entrées avec bouteille".');
        }

        if (errors.length > 0) {
            alert(errors.join('\n'));
            return;
        }

        // Construire l'objet prestation
        const prestation = {
            days,
            presentationLow: this.sanitizeInput(this.accessPresentationLow.value.trim()),
            presentationNormal: this.sanitizeInput(this.accessPresentationNormal.value.trim()),
            presentationAlcohol: this.sanitizeInput(this.accessPresentationAlcohol.value.trim()),
            presentationSoft: this.sanitizeInput(this.accessPresentationSoft.value.trim()),
            price: parseFloat(this.accessPrice.value) || 0,
            sex: this.accessSex.value,
            pureItems: this.buildPureItems()
        };
         console.log('Prestation avant envoi:', prestation);

        const success = await this.saveData(prestation);
        if (success) {
            this.resetForm();
        }
    }

    buildPureItems() {
        if (!document.querySelectorAll('.pure-row').length) {
            return [];
        }

        return Array.from(document.querySelectorAll('.pure-row')).map(row => {
            const category = this.sanitizeInput(row.querySelector('.pure-category-input').value.trim() || '');
            
            const firstDetail = {
                category,
                name: this.sanitizeInput(row.querySelector('.name-section .pure-name').value),
                qty: parseInt(row.querySelector('.name-section .pure-qty').value) || 1,
                price: parseFloat(row.querySelector('.name-section .pure-price').value) || 0,
                maxEntries: this.parseMaxEntries(row.querySelector('.name-section .pure-max-entries')),
                discount: parseFloat(row.querySelector('.name-section .pure-discount').value) || 0
            };

            const additionalDetails = Array.from(row.querySelectorAll('.details-section .details-row')).map(detailRow => ({
                category,
                name: this.sanitizeInput(detailRow.querySelector('.pure-name').value),
                qty: parseInt(detailRow.querySelector('.pure-qty').value) || 1,
                price: parseFloat(detailRow.querySelector('.pure-price').value) || 0,
                maxEntries: this.parseMaxEntries(detailRow.querySelector('.pure-max-entries')),
                discount: parseFloat(detailRow.querySelector('.pure-discount').value) || 0
            }));

            return { details: [firstDetail, ...additionalDetails] };
        }).filter(item => 
            item.details.some(detail => 
                detail.name.trim() && detail.qty && detail.price
            )
        );
    }

    parseMaxEntries(input) {
        try {
            return input.dataset.maxEntries ? JSON.parse(input.dataset.maxEntries) : { 1: 1 };
        } catch (error) {
            console.error('Erreur parsing maxEntries:', error);
            return { 1: 1 };
        }
    }

    // --- AFFICHAGE ---

    renderPrestations() {
        if (!this.accessList || !this.pureList) return;

        this.accessList.style.display = 'block';
        this.pureList.style.display = 'block';
        this.previewSection.style.display = 'none';
        this.accessForm.style.display = 'block';
        
        if (this.previewBtn) {
            this.previewBtn.classList.remove('active');
        }
        
        this.isPreviewActive = false;
        
        this.accessList.innerHTML = '';
        this.pureList.innerHTML = '';

        const filteredPrestations = this.selectedDayFilter 
            ? this.prestations.filter(p => p.days && p.days.includes(this.selectedDayFilter)) 
            : [...this.prestations];

        let hasAccess = false;
        let hasPure = false;

        // Afficher les en-têtes si nécessaire
        if (filteredPrestations.some(p => this.hasAccessData(p))) {
            hasAccess = true;
            this.accessList.innerHTML = this.getAccessHeaderHtml();
        }

        if (filteredPrestations.some(p => p.pureItems && p.pureItems.length > 0)) {
            hasPure = true;
            this.pureList.innerHTML = this.getPureHeaderHtml();
        }

        // Rendre les prestations
        filteredPrestations.forEach((prestation, index) => {
            if (this.hasAccessData(prestation)) {
                this.renderAccessPrestation(prestation, index);
            }
            
            if (prestation.pureItems && prestation.pureItems.length > 0) {
                this.renderPurePrestation(prestation, index);
            }
        });

        // Gérer l'affichage des sections
        this.accessList.style.display = hasAccess ? 'block' : 'none';
        this.pureList.style.display = hasPure ? 'block' : 'none';
        
        if (this.separatorLine) {
            this.separatorLine.style.display = (hasAccess && hasPure) ? 'block' : 'none';
        }

        this.attachPrestationEvents();
    }

    hasAccessData(prestation) {
        return prestation.presentationLow || prestation.presentationNormal || 
               prestation.presentationAlcohol || prestation.presentationSoft || 
               prestation.price;
    }

    getAccessHeaderHtml() {
        return `
            <div class="access-header-row">
                <div class="prestation-label">Les entrées:</div>
                <div class="prestation-label">Prestation:</div>
                <div class="prestation-label">Prix:</div>
                <div class="prestation-label">Sexe:</div>
                <div class="button-container"></div>
            </div>
        `;
    }

    getPureHeaderHtml() {
        return `
            <div class="pure-header-row">
                <div class="prestation-label">Type:</div>
                <div class="prestation-label">Catégorie:</div>
                <div class="prestation-label">Nom:</div>
                <div class="prestation-label">Qt:</div>
                <div class="prestation-label">Prix:</div>
                <div class="prestation-label">Max. Entrée:</div>
                <div class="prestation-label">Réduc. Suppl.:</div>
                <div class="button-container"></div>
            </div>
        `;
    }

    renderAccessPrestation(prestation, index) {
        const accessItem = document.createElement('div');
        accessItem.className = 'prestation-item';
        accessItem.draggable = true;
        accessItem.dataset.index = index;

        const presentationRows = [];
        if (prestation.presentationLow) {
            presentationRows.push({ 
                access: 'Heure creuse', 
                prestation: prestation.presentationLow, 
                price: prestation.price, 
                sex: prestation.sex 
            });
        }
        if (prestation.presentationNormal) {
            presentationRows.push({ 
                access: 'Entrée sans Boisson', 
                prestation: prestation.presentationNormal, 
                price: prestation.price, 
                sex: prestation.sex 
            });
        }
        if (prestation.presentationAlcohol) {
            presentationRows.push({ 
                access: 'Entrée + Alcool', 
                prestation: prestation.presentationAlcohol, 
                price: prestation.price, 
                sex: prestation.sex 
            });
        }
        if (prestation.presentationSoft) {
            presentationRows.push({ 
                access: 'Entrée + Soft', 
                prestation: prestation.presentationSoft, 
                price: prestation.price, 
                sex: prestation.sex 
            });
        }

        const detailRows = presentationRows.map((row, rowIndex) => `
            <div class="access-detail-row ${rowIndex % 2 === 0 ? 'even-row' : 'odd-row'}" data-detail-index="${rowIndex}">
                <div class="prestation-value">${this.sanitizeInput(row.access || '-')}</div>
                <div class="prestation-value">${this.sanitizeInput(row.prestation || '-')}</div>
                <div class="prestation-price">${row.price ? `${row.price}€` : '-'}</div>
                <div class="prestation-value">${this.sanitizeInput(row.sex || '-')}</div>
                <div class="button-container">
                    <button class="edit-btn" aria-label="Éditer la prestation" data-index="${index}">✏️</button>
                    <button class="delete-btn" aria-label="Supprimer la prestation" data-index="${index}">🗑️</button>
                </div>
            </div>
        `).join('');

        accessItem.innerHTML = detailRows;
        this.accessList.appendChild(accessItem);
        this.addDragEvents(accessItem);
    }

    renderPurePrestation(prestation, index) {
        prestation.pureItems.forEach((pure, pureIndex) => {
            const pureItem = document.createElement('div');
            pureItem.className = 'prestation-item pure-item';
            pureItem.draggable = true;
            pureItem.dataset.index = index;

            const detailRows = pure.details.map((detail, detailIndex) => {
                const maxEntriesText = this.formatMaxEntries(detail.maxEntries);
                
                return `
                    <div class="pure-detail-row ${detailIndex % 2 === 0 ? 'even-row' : 'odd-row'}" data-detail-index="${detailIndex}">
                        <div class="prestation-label">Entrée bouteille:</div>
                        <div class="prestation-value">${this.sanitizeInput(detail.category || 'Aucune')}</div>
                        <div class="prestation-value">${this.sanitizeInput(detail.name || '-')}</div>
                        <div class="prestation-qty">${detail.qty || '-'}</div>
                        <div class="prestation-price">${detail.price ? `${detail.price}€` : '-'}</div>
                        <div class="prestation-max" data-tooltip="${this.sanitizeInput(maxEntriesText)}">${this.sanitizeInput(maxEntriesText)}</div>
                        <div class="prestation-discount">${detail.discount ? `${detail.discount}€` : '-'}</div>
                        <div class="button-container">
                            <button class="edit-btn" aria-label="Éditer la prestation" data-index="${index}">✏️</button>
                            <button class="delete-btn" aria-label="Supprimer la prestation" data-index="${index}">🗑️</button>
                        </div>
                    </div>
                `;
            }).join('');

            pureItem.innerHTML = detailRows;
            this.pureList.appendChild(pureItem);
            this.addDragEvents(pureItem);
        });
    }

    formatMaxEntries(maxEntries) {
        try {
            return Object.entries(maxEntries || {})
                .map(([qty, max]) => `${qty}=${max}`)
                .join(', ') || '-';
        } catch (error) {
            return '-';
        }
    }

    attachPrestationEvents() {
        // Boutons d'édition et de suppression
        document.querySelectorAll('.edit-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const index = parseInt(e.target.dataset.index);
                this.editPrestation(index);
            });
        });

        document.querySelectorAll('.delete-btn').forEach(btn => {
            btn.addEventListener('click', async (e) => {
                const index = parseInt(e.target.dataset.index);
                if (confirm('Êtes-vous sûr de vouloir supprimer cette prestation ?')) {
                    await this.deleteData(index);
                }
            });
        });

        // Tooltips
        document.querySelectorAll('.prestation-max[data-tooltip]').forEach(element => {
            if (element.scrollWidth > element.clientWidth) {
                element.addEventListener('mouseenter', (e) => this.showTooltip(e, element));
                element.addEventListener('mouseleave', () => this.hideTooltip());
                element.addEventListener('mousemove', (e) => this.positionTooltip(e, element));
            }
        });
    }

    // --- ÉDITION ---

   editPrestation(index) {
    const prestation = this.prestations[index];
    if (!prestation) return;

    // 1. On mémorise l'ID de la prestation qu'on modifie
    this.editingPrestationId = prestation.id;

    // 2. On charge les données dans le formulaire (votre code est déjà correct)
    document.querySelectorAll('input[name="days"]').forEach(checkbox => {
        checkbox.checked = prestation.days && prestation.days.includes(checkbox.value);
    });
    this.accessPresentationLow.value = prestation.presentationLow || '';
    this.accessPresentationNormal.value = prestation.presentationNormal || '';
    this.accessPresentationAlcohol.value = prestation.presentationAlcohol || '';
    this.accessPresentationSoft.value = prestation.presentationSoft || '';
    this.accessPrice.value = prestation.price || '';
    this.accessSex.value = prestation.sex || 'H/F';
    this.pureContainer.innerHTML = '';
    if (prestation.pureItems && prestation.pureItems.length > 0) {
        prestation.pureItems.forEach(pure => {
            this.loadPureItem(pure);
        });
    }
    if (this.pureContainer.children.length === 0) {
        this.addPure();
    }

    // 3. On met à jour l'interface pour indiquer le mode "édition"
    this.accessList.style.opacity = '0.5';
    this.pureList.style.opacity = '0.5';
    
    // 4. On amène l'utilisateur au formulaire
    const formElement = document.getElementById('access-form');
    if (formElement) {
        formElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
}

    loadPureItem(pure) {
        const pureDiv = document.createElement('div');
        pureDiv.className = 'pure-row';

        const firstDetail = pure.details[0] || { 
            category: '', 
            name: '', 
            qty: '', 
            price: '', 
            maxEntries: { 1: 1 }, 
            discount: 0 
        };
        const additionalDetails = pure.details.slice(1);

        const maxEntriesText = this.formatMaxEntries(firstDetail.maxEntries);

        pureDiv.innerHTML = `
            <div class="category-section">
                <div>
                    <label>Catégorie de bouteille (optionnel)</label>
                    <input type="text" list="bottle-categories" value="${this.sanitizeInput(firstDetail.category)}" 
                           placeholder="Saisir ou sélectionner une catégorie" class="pure-category-input">
                    <datalist id="bottle-categories">
                        <option value="VODKA">
                        <option value="WHISKY">
                        <option value="RUM">
                        <option value="JÄGERBOMB">
                        <option value="CHAMPAGNE">
                    </datalist>
                </div>
            </div>
            <div class="name-section">
                <div>
                    <label>Nom</label>
                    <input type="text" value="${this.sanitizeInput(firstDetail.name)}" class="pure-name">
                </div>
                <div>
                    <label>Qt. bouteilles</label>
                    <input type="number" min="1" value="${firstDetail.qty}" class="pure-qty">
                </div>
                <div>
                    <label>Prix</label>
                    <input type="number" step="0.01" min="0" value="${firstDetail.price}" class="pure-price">
                </div>
                <div>
                    <label>Max. Entrée</label>
                    <input type="text" value="${maxEntriesText}" class="pure-max-entries" readonly 
                           data-max-entries='${JSON.stringify(firstDetail.maxEntries)}'>
                </div>
                <div>
                    <label>Réduc. bouteille suppl.</label>
                    <input type="number" step="0.01" min="0" value="${firstDetail.discount}" class="pure-discount">
                </div>
                <button type="button" class="pure-duplicate-btn" aria-label="Dupliquer la formule">📋</button>
                <button type="button" class="pure-delete-btn" aria-label="Supprimer la formule">🗑️</button>
            </div>
            <div class="details-section">
                ${additionalDetails.map(detail => {
                    const detailMaxText = this.formatMaxEntries(detail.maxEntries);
                    return `
                    <div class="details-row">
                        <div>
                            <label>Nom</label>
                            <input type="text" value="${this.sanitizeInput(detail.name)}" class="pure-name">
                        </div>
                        <div>
                            <label>Qt. bouteilles</label>
                            <input type="number" min="1" value="${detail.qty}" class="pure-qty">
                        </div>
                        <div>
                            <label>Prix</label>
                            <input type="number" step="0.01" min="0" value="${detail.price}" class="pure-price">
                        </div>
                        <div>
                            <label>Max. Entrée</label>
                            <input type="text" value="${detailMaxText}" class="pure-max-entries" readonly 
                                   data-max-entries='${JSON.stringify(detail.maxEntries)}'>
                        </div>
                        <div>
                            <label>Réduc. bouteille suppl.</label>
                            <input type="number" step="0.01" min="0" value="${detail.discount}" class="pure-discount">
                        </div>
                        <button type="button" class="delete-details-btn" aria-label="Supprimer les détails">🗑️</button>
                    </div>
                `}).join('')}
                <button type="button" class="add-details-btn" aria-label="Ajouter des détails">+</button>
            </div>
        `;

        this.pureContainer.appendChild(pureDiv);
        this.bindPureEvents(pureDiv);

        // Attacher les événements aux détails supplémentaires
        pureDiv.querySelectorAll('.details-row').forEach(row => {
            const maxInput = row.querySelector('.pure-max-entries');
            const deleteBtn = row.querySelector('.delete-details-btn');
            
            if (maxInput) {
                maxInput.addEventListener('click', () => this.showMaxEntriesEditor(maxInput));
            }
            if (deleteBtn) {
                deleteBtn.addEventListener('click', () => this.deleteDetails(deleteBtn));
            }
        });
    }

    // --- FILTRAGE ET APERÇU ---

    filterByDay(day) {
        const buttons = document.querySelectorAll('.day-btn');
        
        buttons.forEach(btn => btn.classList.remove('active'));
        
        if (this.previewBtn) {
            this.previewBtn.classList.remove('active');
        }

        this.selectedDayFilter = (this.selectedDayFilter === day) ? null : day;
        
        if (this.selectedDayFilter) {
            const activeBtn = Array.from(buttons).find(btn => btn.textContent.trim() === day);
            if (activeBtn) {
                activeBtn.classList.add('active');
            }
        }

        this.isPreviewActive = false;
        this.renderPrestations();
    }

    showPreview() {
        if (!this.previewSection || !this.accessList || !this.pureList) return;

        this.accessList.style.display = 'none';
        this.pureList.style.display = 'none';
        
        if (this.separatorLine) {
            this.separatorLine.style.display = 'none';
        }
        
        this.accessForm.style.display = 'none';
        this.previewSection.style.display = 'block';
        
        if (this.previewBtn) {
            this.previewBtn.classList.add('active');
        }

        const buttons = document.querySelectorAll('.day-btn');
        buttons.forEach(btn => btn.classList.remove('active'));
        
        this.selectedDayFilter = null;
        this.isPreviewActive = true;

        this.renderPreviewTable();
    }

    renderPreviewTable() {
        const daysOrder = ['Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi', 'Dimanche'];
        
        let html = `
            <table class="preview-table">
                <tr>
                    <th>Jour</th>
                    <th>Les entrées</th>
                    <th>Prestation</th>
                    <th>Catégorie</th>
                    <th>Prix</th>
                    <th>Sexe</th>
                    <th>Qt. bouteilles</th>
                    <th>Max. Entrée</th>
                    <th>Réduc. bouteille suppl.</th>
                </tr>
        `;

        daysOrder.forEach((day) => {
            const dayPrestations = this.prestations.filter(p => p.days && p.days.includes(day));
            const dayClass = `day-${day.toLowerCase()}`;

            if (dayPrestations.length > 0) {
                let allPresentationRows = [];
                let allPureRows = [];

                dayPrestations.forEach((prestation) => {
                    // Lignes d'accès
                    if (prestation.presentationLow) {
                        allPresentationRows.push({
                            access: 'Heure creuse',
                            prestation: prestation.presentationLow,
                            price: prestation.price ? `${prestation.price}€` : '',
                            sex: prestation.sex,
                            category: '', qty: '', maxEntries: '', discount: ''
                        });
                    }
                    if (prestation.presentationNormal) {
                        allPresentationRows.push({
                            access: 'Entrée sans Boisson',
                            prestation: prestation.presentationNormal,
                            price: prestation.price ? `${prestation.price}€` : '',
                            sex: prestation.sex,
                            category: '', qty: '', maxEntries: '', discount: ''
                        });
                    }
                    if (prestation.presentationAlcohol) {
                        allPresentationRows.push({
                            access: 'Entrée + Alcool',
                            prestation: prestation.presentationAlcohol,
                            price: prestation.price ? `${prestation.price}€` : '',
                            sex: prestation.sex,
                            category: '', qty: '', maxEntries: '', discount: ''
                        });
                    }
                    if (prestation.presentationSoft) {
                        allPresentationRows.push({
                            access: 'Entrée + Soft',
                            prestation: prestation.presentationSoft,
                            price: prestation.price ? `${prestation.price}€` : '',
                            sex: prestation.sex,
                            category: '', qty: '', maxEntries: '', discount: ''
                        });
                    }

                    // Lignes de formules bouteille
                    if (prestation.pureItems) {
                        prestation.pureItems.forEach(pure => {
                            pure.details.forEach(detail => {
                                allPureRows.push({
                                    access: 'Bouteille',
                                    prestation: detail.name || '-',
                                    price: detail.price ? `${detail.price}€` : '-',
                                    sex: prestation.sex,
                                    category: detail.category || '',
                                    qty: detail.qty || '-',
                                    maxEntries: this.formatMaxEntries(detail.maxEntries),
                                    discount: detail.discount ? `${detail.discount}€` : ''
                                });
                            });
                        });
                    }
                });

                const rowCount = allPresentationRows.length + allPureRows.length;
                let firstRowOfDay = true;

                [...allPresentationRows, ...allPureRows].forEach(row => {
                    html += `
                        <tr class="${dayClass}">
                            ${firstRowOfDay ? `<td class="day-cell" rowspan="${rowCount}" onclick="gestionEntreesInstance.filterByDay('${day}')">${day}</td>` : ''}
                            <td>${this.sanitizeInput(row.access)}</td>
                            <td>${this.sanitizeInput(row.prestation)}</td>
                            <td>${this.sanitizeInput(row.category)}</td>
                            <td>${row.price}</td>
                            <td>${this.sanitizeInput(row.sex)}</td>
                            <td>${row.qty}</td>
                            <td>${this.sanitizeInput(row.maxEntries)}</td>
                            <td>${row.discount}</td>
                        </tr>
                    `;
                    firstRowOfDay = false;
                });
            } else {
                html += `
                    <tr class="${dayClass}">
                        <td class="day-cell" onclick="gestionEntreesInstance.filterByDay('${day}')">${day}</td>
                        <td colspan="8">Aucune prestation</td>
                    </tr>
                `;
            }
        });

        html += '</table>';
        this.previewSection.innerHTML = html;
    }

    // --- UTILITAIRES ---

    resetForm() {
        // Réinitialiser les cases à cocher
        document.querySelectorAll('input[name="days"]').forEach(checkbox => {
            checkbox.checked = false;
        });

        // Réinitialiser les champs d'accès
        this.accessPresentationLow.value = '';
        this.accessPresentationNormal.value = '';
        this.accessPresentationAlcohol.value = '';
        this.accessPresentationSoft.value = '';
        this.accessPrice.value = '';
        this.accessSex.value = 'H/F';

        // Réinitialiser les formules bouteille
        this.pureContainer.innerHTML = '';
        this.addPure();

            // AJOUTER : Réinitialiser l'ID d'édition et l'opacité de la liste
        this.editingPrestationId = null; 
        if(this.accessList) this.accessList.style.opacity = '1';
        if(this.pureList) this.pureList.style.opacity = '1';

        // Supprimer les classes d'erreur
        document.querySelectorAll('.error').forEach(el => el.classList.remove('error'));
    }

    sanitizeInput(input) {
        const div = document.createElement('div');
        div.textContent = input;
        return div.innerHTML;
    }

    // --- TOOLTIPS ---

    setupTooltips() {
        document.querySelectorAll('.tooltip-icon').forEach(icon => {
            icon.addEventListener('mouseenter', (e) => this.showTooltip(e, icon));
            icon.addEventListener('mouseleave', () => this.hideTooltip());
            icon.addEventListener('mousemove', (e) => this.positionTooltip(e, icon));
        });
    }

    showTooltip(e, element) {
        let tooltip = document.querySelector('.tooltip');
        
        if (!tooltip) {
            tooltip = document.createElement('div');
            tooltip.className = 'tooltip';
            document.body.appendChild(tooltip);
        }

        const tooltipText = element.getAttribute('data-tooltip');
        tooltip.textContent = tooltipText;
        tooltip.classList.add('visible');
        
        this.positionTooltip(e, element);
    }

    hideTooltip() {
        const tooltip = document.querySelector('.tooltip');
        if (tooltip) {
            tooltip.classList.remove('visible');
        }
    }

    positionTooltip(e, element) {
        const tooltip = document.querySelector('.tooltip');
        if (!tooltip || !tooltip.classList.contains('visible')) return;

        const rect = element.getBoundingClientRect();
        const scrollX = window.pageXOffset;
        const scrollY = window.pageYOffset;

        let top = rect.bottom + scrollY + 5;
        let left = rect.left + scrollX + (rect.width / 2) - (tooltip.offsetWidth / 2);

        // Ajustements pour rester dans la fenêtre
        if (top + tooltip.offsetHeight > window.innerHeight + scrollY) {
            top = rect.top + scrollY - tooltip.offsetHeight - 5;
        }
        
        if (left < scrollX) {
            left = scrollX + 5;
        }
        
        if (left + tooltip.offsetWidth > window.innerWidth + scrollX) {
            left = window.innerWidth + scrollX - tooltip.offsetWidth - 5;
        }

        tooltip.style.top = `${top}px`;
        tooltip.style.left = `${left}px`;
    }

    // --- UI HELPERS ---

    showLoading(show) {
        const container = document.querySelector('.gestion-entrees .container');
        if (container) {
            if (show) {
                container.classList.add('loading');
            } else {
                container.classList.remove('loading');
            }
        }
    }

    showMessage(message, type = 'info') {
        // Supprimer les anciens messages
        const existingMessages = document.querySelectorAll('.message');
        existingMessages.forEach(msg => msg.remove());

        // Créer le nouveau message
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${type === 'error' ? 'error-message' : 'success-message'}`;
        messageDiv.textContent = message;
        
        // Insérer le message
        const container = document.querySelector('.gestion-entrees .container');
        if (container) {
            container.insertBefore(messageDiv, container.firstChild);
        }

        // Supprimer automatiquement après 5 secondes
        setTimeout(() => {
            messageDiv.remove();
        }, 5000);
    }
}
