// Fonctions utilitaires pour tooltips intelligentes
function getOptimalTooltipPosition(icon, tooltip) {
    const iconRect = icon.getBoundingClientRect();
    const tooltipRect = tooltip.getBoundingClientRect();
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    const scrollY = window.scrollY;
    
    // Marges de s√©curit√©
    const margin = 20;
    
    // Position par d√©faut : √† droite
    let position = 'right';
    
    // V√©rifier si le tooltip d√©borde √† droite
    if (iconRect.right + tooltipRect.width + margin > viewportWidth) {
        // Essayer √† gauche
        if (iconRect.left - tooltipRect.width - margin > 0) {
            position = 'left';
        } else {
            // Ni √† droite ni √† gauche, essayer en bas
            if (iconRect.bottom + tooltipRect.height + margin < viewportHeight + scrollY) {
                position = 'bottom';
            } else {
                // Sinon en haut
                position = 'top';
            }
        }
    }
    
    // Sur petit √©cran (mobile), forcer en bas
    if (viewportWidth <= 480) {
        position = 'bottom';
    }
    
    return position;
}

function positionTooltip(tooltip, position) {
    // Supprimer toutes les classes de position
    tooltip.classList.remove('tooltip-left', 'tooltip-top', 'tooltip-bottom');
    
    // Ajouter la classe de position appropri√©e
    if (position !== 'right') {
        tooltip.classList.add(`tooltip-${position}`);
    }
}

class GestionHoraires {
    constructor() {
        this.horaires = {};
        this.copiedHoraires = null;
        this.container = null;
        this.init();
    }

   getAuthHeaders() {
    const token = localStorage.getItem('token');
    return {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
    };
} 

async init() {
    console.log('üïê Initialisation Gestion Horaires');
    
    // ‚úÖ AJOUT : V√©rifier si le token est pr√©sent
    const token = localStorage.getItem('token');
    if (!token) {
        console.error('‚ùå Token manquant pour les horaires');
        this.showAlert('Vous devez √™tre connect√© pour acc√©der aux horaires', 'error');
        return;
    }
    
    await this.loadHoraires();
    this.initializeForm();
    this.setupEventListeners();
}

    // Charger les horaires depuis l'API
    async loadHoraires() {
    try {
        console.log('üì° Chargement des horaires...');
        const response = await fetch('/api/horaires', {
            method: 'GET',
            headers: this.getAuthHeaders()
        });
        
        if (response.ok) {
            const data = await response.json(); // üì• Tableau du serveur
            console.log('üì• Donn√©es re√ßues du serveur:', data);
            this.horaires = this.formatHorairesData(data); // üîÑ Conversion
            console.log('üîÑ Donn√©es format√©es:', this.horaires);
        } else {
            this.horaires = this.getDefaultHoraires();
        }
    } catch (error) {
        console.error('‚ùå Erreur lors du chargement des horaires:', error);
        this.horaires = this.getDefaultHoraires();
    }
}

    // Format par d√©faut des horaires
    getDefaultHoraires() {
        return {
            lundi: { slot1: {debut: '', fin: ''}, slot2: {debut: '', fin: ''} },
            mardi: { slot1: {debut: '', fin: ''}, slot2: {debut: '', fin: ''} },
            mercredi: { slot1: {debut: '', fin: ''}, slot2: {debut: '', fin: ''} },
            jeudi: { slot1: {debut: '', fin: ''}, slot2: {debut: '', fin: ''} },
            vendredi: { slot1: {debut: '', fin: ''}, slot2: {debut: '', fin: ''} },
            samedi: { slot1: {debut: '', fin: ''}, slot2: {debut: '', fin: ''} },
            dimanche: { slot1: {debut: '', fin: ''}, slot2: {debut: '', fin: ''} }
        };
    }

    // Formater les donn√©es de l'API
    formatHorairesData(dataArray) {
  const jours = ['lundi', 'mardi', 'mercredi', 'jeudi', 'vendredi', 'samedi', 'dimanche'];
  const formattedHoraires = {};

  // Init
  jours.forEach(jour => {
    formattedHoraires[jour] = {
      slot1: { debut: '', fin: '' },
      slot2: { debut: '', fin: '' }
    };
  });

  // Normalise "HH:MM:SS" -> "HH:MM"
  const toHHMM = (t) => (typeof t === 'string' ? t.slice(0,5) : t || '');

  dataArray.forEach(horaire => {
    const jour = String(horaire.jour_semaine || '').toLowerCase();
    const slot = Number(horaire.slot_numero);
    const slotKey = slot === 2 ? 'slot2' : 'slot1';

    if (formattedHoraires[jour]) {
      formattedHoraires[jour][slotKey] = {
        debut: toHHMM(horaire.heure_debut),
        fin:   toHHMM(horaire.heure_fin)
      };
    }
  });

  return formattedHoraires;
}

    // Initialiser le formulaire avec les donn√©es
    initializeForm() {
        if (!this.container) return;
        
        this.container.querySelectorAll('tbody tr').forEach(row => {
            const day = row.dataset.day;
            if (!this.horaires[day]) return;

            const slot1Debut = row.querySelector('.heure-debut-1');
            const slot1Fin = row.querySelector('.heure-fin-1');
            const slot2Debut = row.querySelector('.heure-debut-2');
            const slot2Fin = row.querySelector('.heure-fin-2');

            if (slot1Debut) slot1Debut.value = this.horaires[day].slot1.debut || '';
            if (slot1Fin) slot1Fin.value = this.horaires[day].slot1.fin || '';
            if (slot2Debut) slot2Debut.value = this.horaires[day].slot2.debut || '';
            if (slot2Fin) slot2Fin.value = this.horaires[day].slot2.fin || '';
        });
    }

    // Configurer les event listeners
    setupEventListeners() {
        if (!this.container) return;

        // Boutons copier
        this.container.querySelectorAll('.copy-btn').forEach(button => {
            button.addEventListener('click', (e) => {
                const day = e.target.getAttribute('data-day');
                const slot = e.target.getAttribute('data-slot');
                this.copyHoraires(day, slot);
            });
        });

        // Boutons coller
        this.container.querySelectorAll('.paste-btn').forEach(button => {
            button.addEventListener('click', (e) => {
                const day = e.target.getAttribute('data-day');
                const slot = e.target.getAttribute('data-slot');
                this.pasteHoraires(day, slot);
            });
        });

        // Bouton sauvegarder
        const saveBtn = this.container.querySelector('#save-horaires-btn');
        if (saveBtn) {
            saveBtn.addEventListener('click', () => this.saveHoraires());
        }

        // Tooltips intelligentes
        this.setupTooltips();
    }

    // Copier les horaires
    copyHoraires(day, slot) {
        const row = this.container.querySelector(`tr[data-day="${day}"]`);
        if (!row) return;

        const debutInput = row.querySelector(`.heure-debut-${slot}`);
        const finInput = row.querySelector(`.heure-fin-${slot}`);

        if (!debutInput?.value || !finInput?.value) {
            this.showAlert('Veuillez d\'abord d√©finir des horaires √† copier.', 'error');
            return;
        }

        this.copiedHoraires = {
            debut: debutInput.value,
            fin: finInput.value
        };

        console.log(`Copi√© depuis ${day} slot ${slot}:`, this.copiedHoraires);
        this.showAlert(`Horaires de ${day} (Plage ${slot}) copi√©s !`, 'success');
    }

    // Coller les horaires
    pasteHoraires(day, slot) {
        if (!this.copiedHoraires) {
            this.showAlert('Aucun horaire copi√©. Veuillez copier un horaire d\'abord.', 'error');
            return;
        }

        const row = this.container.querySelector(`tr[data-day="${day}"]`);
        if (!row) return;

        const debutInput = row.querySelector(`.heure-debut-${slot}`);
        const finInput = row.querySelector(`.heure-fin-${slot}`);

        if (debutInput && finInput) {
            debutInput.value = this.copiedHoraires.debut;
            finInput.value = this.copiedHoraires.fin;

            // Mettre √† jour l'objet horaires
            this.horaires[day][`slot${slot}`] = {
                debut: this.copiedHoraires.debut,
                fin: this.copiedHoraires.fin
            };

            this.showAlert(`Horaires coll√©s √† ${day} (Plage ${slot}) !`, 'success');
        }
    }

    updateHorairesFromForm() {
    const jours = ["lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi", "dimanche"];
    const horaires = [];
    // on repart d'un √©tat propre et on le remplira depuis le DOM
    const newState = this.getDefaultHoraires();

    jours.forEach(jour => {
        const row = this.container.querySelector(`tr[data-day="${jour}"]`);
        if (!row) return;

        // Slot 1
        const debut1 = row.querySelector('.heure-debut-1')?.value || null;
        const fin1   = row.querySelector('.heure-fin-1')?.value   || null;

        horaires.push({
            jour_semaine: jour,
            slot_numero: 1,
            heure_debut: (debut1 && fin1) ? debut1 : null,
            heure_fin:   (debut1 && fin1) ? fin1   : null
        });
        newState[jour].slot1 = { debut: debut1 || '', fin: fin1 || '' };

        // Slot 2
        const debut2 = row.querySelector('.heure-debut-2')?.value || null;
        const fin2   = row.querySelector('.heure-fin-2')?.value   || null;

        horaires.push({
            jour_semaine: jour,
            slot_numero: 2,
            heure_debut: (debut2 && fin2) ? debut2 : null,
            heure_fin:   (debut2 && fin2) ? fin2   : null
        });
        newState[jour].slot2 = { debut: debut2 || '', fin: fin2 || '' };
    });

    // Synchroniser l'√©tat interne avant la validation
    this.horaires = newState;

    // Tr√®s important: ne pas faire de fetch ici
    return horaires;
}

async saveHoraires() {
    if (this.isSaving) return;
    this.isSaving = true;

    const confirmed = await this.showConfirmation('Souhaitez-vous enregistrer les modifications ?');
    if (!confirmed) { this.isSaving = false; return; }

    try {
        // 1) R√©cup√©rer les valeurs du DOM + synchroniser this.horaires
        const horairesPourAPI = this.updateHorairesFromForm(); // ‚Üê retourne bien un tableau maintenant
        if (!Array.isArray(horairesPourAPI)) {
            throw new Error("Collecte des horaires √©chou√©e.");
        }

        // 2) Validation (maintenant this.horaires correspond aux inputs)
        const jours = ['lundi','mardi','mercredi','jeudi','vendredi','samedi','dimanche'];
        for (const day of jours) {
            const slot1 = this.horaires[day].slot1;
            const slot2 = this.horaires[day].slot2;

            const s1Valide = slot1.debut && slot1.fin;
            const s2Valide = slot2.debut && slot2.fin;

            if (s1Valide && !this.isTimeAfter(slot1.fin, slot1.debut)) {
                this.showAlert(`Erreur pour ${day} (Plage 1) : l'heure de fin doit √™tre apr√®s le d√©but.`, 'error');
                this.isSaving = false;
                return;
            }
            if (s2Valide && !this.isTimeAfter(slot2.fin, slot2.debut)) {
                this.showAlert(`Erreur pour ${day} (Plage 2) : l'heure de fin doit √™tre apr√®s le d√©but.`, 'error');
                this.isSaving = false;
                return;
            }
            if (s1Valide && s2Valide) {
                const debut1 = new Date(`1970-01-01T${slot1.debut}`);
                const fin1   = new Date(`1970-01-01T${slot1.fin}`);
                const debut2 = new Date(`1970-01-01T${slot2.debut}`);
                const fin2   = new Date(`1970-01-01T${slot2.fin}`);
                const chevauchement = Math.max(debut1, debut2) < Math.min(fin1, fin2);
                if (chevauchement) {
                    this.showAlert(`Erreur pour ${day} : les plages 1 et 2 se chevauchent.`, 'error');
                    this.isSaving = false;
                    return;
                }
            }
        }

        // 3) Envoi unique au backend avec auth
        console.log('üì§ Payload horaires envoy√©e:', horairesPourAPI);
        const response = await fetch('/api/horaires', {
            method: 'POST',
            headers: this.getAuthHeaders(),
            body: JSON.stringify({ horaires: horairesPourAPI })
        });

        if (response.ok) {
            this.showAlert('Horaires sauvegard√©s avec succ√®s!', 'success');
        } else {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.message || 'Erreur lors de la sauvegarde c√¥t√© serveur');
        }

    } catch (error) {
        console.error('‚ùå Erreur de sauvegarde:', error);
        this.showAlert(`Une erreur est survenue: ${error.message}`, 'error');
    } finally {
        this.isSaving = false;
    }
}

// NOUVELLE VERSION AM√âLIOR√âE
async showConfirmation(message) {
    return new Promise((resolve) => {
        // 1. On utilise les nouvelles classes CSS unifi√©es
        const modalHtml = `
            <div class="unified-confirmation-modal" role="alertdialog" aria-modal="true" aria-labelledby="modal-message">
                <div class="modal-content">
                    <p id="modal-message" class="modal-message">${message}</p>
                    <div class="modal-buttons">
                        <button class="modal-btn btn-confirm" id="confirm-yes">Oui</button>
                        <button class="modal-btn btn-cancel" id="confirm-no">Non</button>
                    </div>
                </div>
            </div>
        `;

        document.body.insertAdjacentHTML('beforeend', modalHtml);
        const modal = document.querySelector('.unified-confirmation-modal:last-child');
        
        // 2. On ajoute la classe .show pour d√©clencher l'animation d'ouverture
        //    requestAnimationFrame garantit que la transition se joue correctement
        requestAnimationFrame(() => {
            modal.classList.add('show');
        });

        const yesBtn = modal.querySelector('#confirm-yes');
        const noBtn = modal.querySelector('#confirm-no');

        // 3. La fonction de nettoyage g√®re maintenant l'animation de fermeture
        const cleanup = () => {
            document.body.classList.remove('modal-open'); // R√©activer le scroll
            modal.classList.add('closing'); // D√©clencher l'animation de fermeture
            
            // Supprimer l'√©l√©ment du DOM apr√®s la fin de l'animation
            modal.addEventListener('animationend', () => {
                if (modal.parentNode) {
                    modal.parentNode.removeChild(modal);
                }
            }, { once: true });
        };

        const handleResolve = (value) => {
            cleanup();
            resolve(value);
        };

        yesBtn.onclick = () => handleResolve(true);
        noBtn.onclick = () => handleResolve(false);

        modal.onclick = (e) => {
            if (e.target === modal) {
                handleResolve(false); // Annuler si on clique sur le fond
            }
        };
        
        // G√©rer la touche "Echap" pour fermer
        const handleKeyDown = (e) => {
            if (e.key === 'Escape') {
                handleResolve(false);
                document.removeEventListener('keydown', handleKeyDown);
            }
        };
        document.addEventListener('keydown', handleKeyDown);
        
        // 4. Bloquer le scroll de la page en arri√®re-plan
        document.body.classList.add('modal-open');
    });
}

    // V√©rifier si time1 est apr√®s time2
    isTimeAfter(time1, time2) {
        return new Date(`2000-01-01 ${time1}`) > new Date(`2000-01-01 ${time2}`);
    }

    // VERSION AM√âLIOR√âE : Configurer les tooltips intelligentes
    setupTooltips() {
        const tooltipIcons = this.container ? 
            this.container.querySelectorAll('.tooltip-icon') : 
            document.querySelectorAll('.tooltip-icon');
        
        tooltipIcons.forEach(icon => {
            const tooltipId = icon.getAttribute('data-tooltip');
            const tooltip = document.getElementById(`tooltip-${tooltipId}`);
            
            if (tooltip) {
                let timeoutId;
                
                // Mouseenter avec d√©lai
                icon.addEventListener('mouseenter', () => {
                    clearTimeout(timeoutId);
                    
                    // Afficher le tooltip temporairement pour calculer sa taille
                    tooltip.style.visibility = 'hidden';
                    tooltip.classList.add('visible');
                    
                    // Calculer la meilleure position
                    const optimalPosition = getOptimalTooltipPosition(icon, tooltip);
                    positionTooltip(tooltip, optimalPosition);
                    
                    // Afficher avec animation
                    tooltip.style.visibility = 'visible';
                    tooltip.style.opacity = '0';
                    tooltip.style.transition = 'opacity 0.2s ease-in-out';
                    
                    requestAnimationFrame(() => {
                        tooltip.style.opacity = '1';
                    });
                });
                
                // Mouseleave avec d√©lai pour √©viter les clignotements
                icon.addEventListener('mouseleave', () => {
                    timeoutId = setTimeout(() => {
                        tooltip.style.opacity = '0';
                        setTimeout(() => {
                            if (tooltip.style.opacity === '0') {
                                tooltip.classList.remove('visible');
                                tooltip.style.transition = '';
                            }
                        }, 200);
                    }, 100);
                });
                
                // Garder le tooltip ouvert quand on survole le tooltip lui-m√™me
                tooltip.addEventListener('mouseenter', () => {
                    clearTimeout(timeoutId);
                });
                
                tooltip.addEventListener('mouseleave', () => {
                    timeoutId = setTimeout(() => {
                        tooltip.style.opacity = '0';
                        setTimeout(() => {
                            if (tooltip.style.opacity === '0') {
                                tooltip.classList.remove('visible');
                                tooltip.style.transition = '';
                            }
                        }, 200);
                    }, 100);
                });
            }
        });
        
        // Recalculer les positions lors du redimensionnement
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                // Repositionner les tooltips visibles
                const visibleTooltips = document.querySelectorAll('.tooltip.visible');
                visibleTooltips.forEach(tooltip => {
                    const tooltipId = tooltip.id.replace('tooltip-', '');
                    const icon = document.querySelector(`[data-tooltip="${tooltipId}"]`);
                    if (icon) {
                        const optimalPosition = getOptimalTooltipPosition(icon, tooltip);
                        positionTooltip(tooltip, optimalPosition);
                    }
                });
            }, 150);
        });
    }

    // D√©finir le conteneur
    setContainer(container) {
        this.container = container;
        this.setupEventListeners();
        this.initializeForm();
    }

    // Afficher une alerte
    showAlert(message, type = 'info') {
        // Cr√©er une alerte simple compatible avec ton syst√®me
        const alertDiv = document.createElement('div');
        alertDiv.className = `alert alert-${type}`;
        alertDiv.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 8px;
            color: white;
            z-index: 10000;
            font-weight: 500;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
            max-width: 350px;
            transform: translateX(100%);
            opacity: 0;
        `;
        
        // Couleurs selon le type
        if (type === 'success') {
            alertDiv.style.background = 'linear-gradient(135deg, #4CAF50, #45a049)';
        } else if (type === 'error') {
            alertDiv.style.background = 'linear-gradient(135deg, #f44336, #da190b)';
        } else {
            alertDiv.style.background = 'linear-gradient(135deg, #2196F3, #1976D2)';
        }
        
        alertDiv.textContent = message;
        document.body.appendChild(alertDiv);
        
        // Animation d'entr√©e
        setTimeout(() => {
            alertDiv.style.transform = 'translateX(0)';
            alertDiv.style.opacity = '1';
        }, 100);
        
        // Suppression automatique
        setTimeout(() => {
            alertDiv.style.transform = 'translateX(100%)';
            alertDiv.style.opacity = '0';
            setTimeout(() => {
                if (alertDiv.parentNode) {
                    alertDiv.parentNode.removeChild(alertDiv);
                }
            }, 300);
        }, 3000);
    }

    // Cette m√©thode peut √™tre supprim√©e car setupTooltips() fait maintenant tout
    initTooltips() {
        this.setupTooltips(); // Utilise la version am√©lior√©e
    }

    // Rendu du contenu HTML
    render() {
    return `
        <div class="horaires-container">
            <div class="section-header">
                <h2>Gestion des Horaires</h2>
                <p class="section-subtitle" style="text-align: center;">D√©finissez les plages horaires creuses pour chaque jour</p>
            </div>
                
                <div class="tarif-table">
                    <table class="horaires-table">
                        <thead>
                            <tr>
                                <th>Jour</th>
                               <th>
    Plage Horaire Creuse 1
    <span class="tooltip-icon" data-tooltip="creuse1">?</span>
    <div id="tooltip-creuse1" class="tooltip">D√©finissez la premi√®re plage horaire creuse (par exemple, heures de faible affluence o√π un tarif r√©duit s'applique).</div>
</th>
<th>
    Plage Horaire Creuse 2
    <span class="tooltip-icon" data-tooltip="creuse2">?</span>
    <div id="tooltip-creuse2" class="tooltip">D√©finissez la seconde plage horaire creuse (optionnelle, pour une autre p√©riode de la journ√©e).</div>
</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${this.renderDayRows()}
                        </tbody>
                    </table>
                    
                    <button id="save-horaires-btn" class="save-btn">
                        Sauvegarder les Horaires
                    </button>
                </div>
            </div>
        `;
    }

    // Rendu des lignes de jours
    renderDayRows() {
        const jours = ['lundi', 'mardi', 'mercredi', 'jeudi', 'vendredi', 'samedi', 'dimanche'];
        const jourLabels = ['Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi', 'Dimanche'];
        
        return jours.map((jour, index) => `
            <tr data-day="${jour}">
                <td>${jourLabels[index]}</td>
                <td>
                    <div class="time-row">
                        <div class="time-inputs">
                            <input type="time" class="heure-debut-1" aria-label="D√©but heures creuses 1"> - 
                            <input type="time" class="heure-fin-1" aria-label="Fin heures creuses 1">
                        </div>
                        <div class="action-buttons">
                            <button class="copy-btn" data-day="${jour}" data-slot="1" title="Copier"></button>
                            <button class="paste-btn" data-day="${jour}" data-slot="1" title="Coller"></button>
                        </div>
                    </div>
                </td>
                <td>
                    <div class="time-row">
                        <div class="time-inputs">
                            <input type="time" class="heure-debut-2" aria-label="D√©but heures creuses 2"> - 
                            <input type="time" class="heure-fin-2" aria-label="Fin heures creuses 2">
                        </div>
                        <div class="action-buttons">
                            <button class="copy-btn" data-day="${jour}" data-slot="2" title="Copier"></button>
                            <button class="paste-btn" data-day="${jour}" data-slot="2" title="Coller"></button>
                        </div>
                    </div>
                </td>
            </tr>
        `).join('');
    }
}

// Export pour utilisation
window.GestionHoraires = GestionHoraires;
