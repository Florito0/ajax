class GestionEntrees {
    constructor() {
        this.prestations = [];
        this.kioskItems = {};
        this.selectedDayFilter = null;
        this.isPreviewActive = false;
        this.draggedItem = null;
        this.draggedPure = null;
        this.editingPrestationId = null;
        this.token = localStorage.getItem('token');
        this.apiBaseUrl = '/api/entrees';
        
        // Initialisation des √©l√©ments DOM
        this.initializeElements();

        // CORRECTION : Appeler bindEvents() ICI, dans le constructeur.
        // Il ne sera ainsi ex√©cut√© qu'une seule fois.
        this.bindEvents();
    }

      initializeElements() {
        // --- Panneau Admin ---
        this.dashboardContainer = document.getElementById('gestion-tickets-entree'); // MODIFI√â
        this.accessList = document.getElementById('access-prestations-list');
        this.pureList = document.getElementById('pure-prestations-list');
        this.separatorLine = document.getElementById('separator-line');
        this.previewSection = document.getElementById('preview-section');
        this.accessForm = document.getElementById('access-form');
        this.pureContainer = document.getElementById('pure-container');
        this.saveBtn = document.querySelector('.gestion-entrees .save-btn');
        this.previewBtn = document.querySelector('.gestion-entrees .preview-btn');
        
        // Champs de formulaire
        this.daysCheckboxes = document.getElementById('days-checkboxes');
        this.accessPresentationLow = document.getElementById('access-presentation-low');
        this.accessPresentationNormal = document.getElementById('access-presentation-normal');
        this.accessPresentationAlcohol = document.getElementById('access-presentation-alcohol');
        this.accessPresentationSoft = document.getElementById('access-presentation-soft');
        this.accessPrice = document.getElementById('access-price');
        this.accessSex = document.getElementById('access-sex');

        // --- Panneau Kiosque (NOUVEAU) ---
        this.toggleBtn = document.getElementById('toggle-interface-btn');
        this.kioskContainer = document.getElementById('kiosk-view');
        this.kioskSubtitle = document.getElementById('kiosk-subtitle');
        this.kioskAccessContainer = document.getElementById('access-items-kiosk');
        this.kioskPureContainer = document.getElementById('pure-items-kiosk');
        this.kioskAccessSection = document.getElementById('access-soiree-kiosk');
        this.kioskPureSection = document.getElementById('pure-soiree-kiosk');
        this.kioskSeparator = this.kioskContainer.querySelector('.kiosk-separator');
        this.kioskTotalDiscount = document.getElementById('kiosk-total-discount');
        this.kioskTotalPrice = document.getElementById('kiosk-total-price');
        this.kioskCheckoutBtn = document.getElementById('kiosk-checkout-btn');
    }

    async init() {
        await this.loadData();
        this.addPure();
        this.renderPrestations();
        this.setupTooltips();
        this.renderKioskItems();

        const today = new Date();
        const daysOfWeek = ["Dimanche", "Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi", "Samedi"];
        const currentDay = daysOfWeek[today.getDay()];
        if (this.kioskSubtitle) {
            this.kioskSubtitle.textContent = `Aujourd'hui : ${currentDay} ${today.toLocaleDateString('fr-FR')}`;
        }
    }

    // --- M√âTHODES DE CHARGEMENT ET SAUVEGARDE ---

    async loadData() {
        if (!this.token) {
            console.warn('Aucun token disponible');
            return;
        }

        try {
            const response = await fetch(this.apiBaseUrl, {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${this.token}`,
                    'Content-Type': 'application/json'
                }
            });

            if (!response.ok) {
                throw new Error(`Erreur HTTP: ${response.status}`);
            }

            const data = await response.json();
            this.prestations = Array.isArray(data) ? data : [];
            this.renderPrestations();
            this.renderKioskItems();
        } catch (error) {
            console.error('Erreur lors du chargement des donn√©es:', error);
            this.showMessage('Erreur lors du chargement des prestations', 'error');
        }
    }

    async saveData(prestation) {
        if (!this.token) {
            this.showMessage('Token manquant', 'error');
            return false;
        }

        try {
            this.showLoading(true);

            console.log('Donn√©es envoy√©es √† l\'API:', JSON.stringify(prestation, null, 2));   

            const response = await fetch(this.apiBaseUrl, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${this.token}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(prestation)
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.message || `Erreur HTTP: ${response.status}`);
            }

            const result = await response.json();
            this.showMessage('Prestation enregistr√©e avec succ√®s', 'success');
            await this.loadData();
            return true;
        } catch (error) {
            console.error('Erreur lors de la sauvegarde:', error);
            this.showMessage(`Erreur: ${error.message}`, 'error');
            return false;
        } finally {
            this.showLoading(false);
        }
    }

    async updateData(id, prestation) {
        if (!this.token) {
            this.showMessage('Token manquant', 'error');
            return false;
        }

        try {
            this.showLoading(true);
            const response = await fetch(`${this.apiBaseUrl}/${id}`, {
                method: 'PUT',
                headers: {
                    'Authorization': `Bearer ${this.token}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(prestation)
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.message || `Erreur HTTP: ${response.status}`);
            }

            this.showMessage('Prestation mise √† jour avec succ√®s', 'success');
            await this.loadData();
            return true;
        } catch (error) {
            console.error('Erreur lors de la mise √† jour:', error);
            this.showMessage(`Erreur: ${error.message}`, 'error');
            return false;
        } finally {
            this.showLoading(false);
        }
    }

    async deleteData(index) {
        if (!this.token || !this.prestations[index]) {
            return false;
        }

        const prestation = this.prestations[index];
        if (!prestation.id) {
            this.prestations.splice(index, 1);
            this.renderPrestations();
            this.updateOrderNumbers();
            return true;
        }

        try {
            this.showLoading(true);

            const response = await fetch(`${this.apiBaseUrl}/${prestation.id}`, {
                method: 'DELETE',
                headers: {
                    'Authorization': `Bearer ${this.token}`,
                    'Content-Type': 'application/json'
                }
            });

            if (!response.ok) {
                throw new Error(`Erreur HTTP: ${response.status}`);
            }

            this.showMessage('Prestation supprim√©e avec succ√®s', 'success');
            await this.loadData();
            this.updateOrderNumbers();
            return true;
        } catch (error) {
            console.error('Erreur lors de la suppression:', error);
            this.showMessage(`Erreur: ${error.message}`, 'error');
            return false;
        } finally {
            this.showLoading(false);
        }
    }

    toggleInterface() {
        const adminContent = this.dashboardContainer.querySelector('.container'); // Cible le contenu int√©rieur

        if (adminContent.style.display === 'none') {
            adminContent.style.display = 'block';
            this.kioskContainer.style.display = 'none';
            this.toggleBtn.textContent = 'Passer au Kiosque';
        } else {
            adminContent.style.display = 'none';
            this.kioskContainer.style.display = 'block';
            this.toggleBtn.textContent = "Retour √† l'administration";
        }
    }

    renderKioskItems() {
        if (!this.kioskContainer) return;

        this.kioskAccessContainer.innerHTML = '';
        this.kioskPureContainer.innerHTML = '';
        this.kioskItems = {};
        
        const today = new Date();
        const daysOfWeek = ["Dimanche", "Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi", "Samedi"];
        const currentDay = daysOfWeek[today.getDay()];
        
        const todayPrestations = this.prestations.filter(p => p.days && p.days.includes(currentDay));
        let hasAccess = false;
        let hasPure = false;

        todayPrestations.forEach((prestation, prestationIndex) => {
            if (this.hasAccessData(prestation)) {
                hasAccess = true;
                const price = parseFloat(prestation.price) || 0;
                ['Low', 'Normal', 'Alcohol', 'Soft'].forEach(type => {
                    const presentationName = prestation[`presentation${type}`];
                    if (presentationName) {
                        const id = `access-${type.toLowerCase()}-${prestationIndex}`;
                        this.kioskItems[id] = { name: presentationName, price, qty: 0, maxQty: 10 };
                        this.kioskAccessContainer.innerHTML += this.createKioskItemHTML(id, presentationName, price);
                    }
                });
            }

            // Logique pour les formules bouteille
            if (prestation.pureItems && prestation.pureItems.length > 0) {
                hasPure = true;
                prestation.pureItems.forEach((pure, pureIndex) => {
                    pure.details.forEach((detail, detailIndex) => {
                        const id = `pure-${prestationIndex}-${pureIndex}-${detailIndex}`;
                        const maxQty = detail.maxEntries ? Math.max(...Object.keys(detail.maxEntries).map(Number)) : 1;
                        this.kioskItems[id] = {
                            name: detail.name,
                            category: detail.category || '',
                            price: parseFloat(detail.price) || 0,
                            maxEntries: detail.maxEntries || { 1: 1 },
                            currentMaxEntries: (detail.maxEntries && detail.maxEntries[1]) ? detail.maxEntries[1] : 1,
                            discount: parseFloat(detail.discount) || 0,
                            qty: 0,
                            maxQty: maxQty
                        };
                        this.kioskPureContainer.innerHTML += this.createKioskItemHTML(id, detail.name, detail.price, detail.maxEntries);
                    });
                });
            }
        });
        
        this.kioskAccessSection.style.display = hasAccess ? 'block' : 'none';
        this.kioskPureSection.style.display = hasPure ? 'block' : 'none';
        this.kioskSeparator.style.display = (hasAccess && hasPure) ? 'block' : 'none';

        this.attachKioskQuantityListeners();
        this.updateKioskTotal();
    }

    createKioskItemHTML(id, name, price, maxEntries = null) {
        let maxEntriesHTML = '';
        if (maxEntries) {
            const initialMax = (maxEntries && maxEntries[1]) ? maxEntries[1] : 1;
            maxEntriesHTML = `<div class="kiosk-item-max" id="${id}-max-entries">Max. Entr√©es: <span class="kiosk-max-value">${initialMax}</span></div>`;
        }

        return `
            <div class="kiosk-item">
                <div class="kiosk-item-content">
                    <div class="kiosk-item-name">${this.sanitizeInput(name)}</div>
                    <div class="kiosk-item-price-container">
                        <div class="kiosk-item-price">${price}‚Ç¨</div>
                        ${maxEntriesHTML}
                    </div>
                    <div class="kiosk-quantity-control">
                        <button class="kiosk-qty-btn" data-id="${id}" data-action="decrease">-</button>
                        <div id="${id}-qty" class="kiosk-qty-value">0</div>
                        <button class="kiosk-qty-btn" data-id="${id}" data-action="increase">+</button>
                    </div>
                </div>
            </div>`;
    }

    attachKioskQuantityListeners() {
        this.kioskContainer.querySelectorAll('.kiosk-qty-btn').forEach(button => {
            button.replaceWith(button.cloneNode(true));
        });
        this.kioskContainer.querySelectorAll('.kiosk-qty-btn').forEach(button => {
            button.addEventListener('click', (event) => this.handleKioskQuantityClick(event));
        });
    }

    handleKioskQuantityClick(event) {
        const button = event.currentTarget;
        const id = button.dataset.id;
        const action = button.dataset.action;
        this.updateKioskQuantity(id, action === 'increase' ? 1 : -1);
    }
    
    updateKioskQuantity(itemId, change) {
        if (!this.kioskItems[itemId]) return;
        const item = this.kioskItems[itemId];
        const newQty = item.qty + change;

        if (newQty >= 0 && newQty <= (item.maxQty || 10)) {
            item.qty = newQty;
            document.getElementById(`${itemId}-qty`).textContent = newQty;
            
            if (item.maxEntries) {
                item.currentMaxEntries = item.maxEntries[newQty] || item.currentMaxEntries;
                const maxEntriesElement = document.getElementById(`${itemId}-max-entries`);
                if (maxEntriesElement) {
                    maxEntriesElement.querySelector('.kiosk-max-value').textContent = item.currentMaxEntries || 0;
                }
            }
            this.updateKioskTotal();
        }
    }
    
    updateKioskTotal() {
        let total = 0;
        let discountTotal = 0;
        let itemCount = 0;
        for (const item of Object.values(this.kioskItems)) {
            total += (item.price || 0) * item.qty;
            itemCount += item.qty;
            if (item.discount > 0 && item.qty > 1) {
                discountTotal += (item.qty - 1) * item.discount;
            }
        }
        this.kioskTotalPrice.textContent = `${(total - discountTotal).toFixed(2)}‚Ç¨`;
        this.kioskTotalDiscount.textContent = discountTotal > 0 ? `(R√©duc.: -${discountTotal.toFixed(2)}‚Ç¨)` : '';
        this.kioskCheckoutBtn.disabled = itemCount === 0;
    }

    handleKioskCheckout() {
        let summary = 'R√©capitulatif de la commande :\n';
        // ... (logique de l'ancien code pour g√©n√©rer le r√©capitulatif) ...
        alert(summary);
    }

    updateOrderNumbers() {
        // Mise √† jour des ordres dans access-prestations-list
        const accessItems = this.accessList.querySelectorAll('.prestation-item');
        accessItems.forEach((item, index) => {
            const orderElement = item.querySelector('.prestation-order');
            if (orderElement) {
                orderElement.textContent = index + 1;
            }
            item.dataset.order = index + 1;
        });
        
        // Mise √† jour des ordres dans pure-prestations-list
        const pureItems = this.pureList.querySelectorAll('.prestation-item.pure-item');
        let currentOrder = 1;
        let lastIndex = null;
        
        pureItems.forEach((item) => {
            const itemIndex = item.dataset.index;
            
            // Si c'est un nouvel index de prestation, on incr√©mente l'ordre
            if (lastIndex !== itemIndex) {
                const orderElement = item.querySelector('.prestation-order-pure');
                if (orderElement) {
                    orderElement.textContent = currentOrder;
                }
                item.dataset.order = currentOrder;
                currentOrder++;
                lastIndex = itemIndex;
            } else {
                // M√™me prestation, on garde le m√™me ordre
                item.dataset.order = currentOrder - 1;
            }
        });
    }

    // --- GESTION DES √âV√âNEMENTS ---

     bindEvents() {
        if (this.saveBtn) {
            this.saveBtn.addEventListener('click', () => this.savePrestation());
        }

        if (this.toggleBtn) {
            this.toggleBtn.addEventListener('click', () => this.toggleInterface());
        }
        
        if(this.kioskCheckoutBtn) {
            this.kioskCheckoutBtn.addEventListener('click', () => this.handleKioskCheckout());
        }

        document.querySelectorAll('.day-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const day = e.target.textContent.trim();
                this.filterByDay(day);
            });
        });

        if (this.previewBtn) {
            this.previewBtn.addEventListener('click', () => this.showPreview());
        }

        const addPureBtn = document.querySelector('.add-pure-btn');
        if (addPureBtn) {
            addPureBtn.addEventListener('click', () => this.addPure());
        }

        document.addEventListener('click', (e) => {
            const editors = document.querySelectorAll('.max-entries-editor');
            editors.forEach(editor => {
                if (!editor.contains(e.target) && 
                    !editor.parentElement.querySelector('.pure-max-entries').contains(e.target)) {
                    editor.style.display = 'none';
                }
            });
        });
    }

    // --- GESTION DES FORMULES BOUTEILLE ---

    addPure() {
        const pureDiv = document.createElement('div');
        pureDiv.className = 'pure-row';
        pureDiv.innerHTML = `
            <div class="category-section">
                <div>
                    <label>Cat√©gorie de bouteille (optionnel)</label>
                    <input type="text" list="bottle-categories" placeholder="Saisir ou s√©lectionner une cat√©gorie" class="pure-category-input">
                    <datalist id="bottle-categories">
                        <option value="VODKA">
                        <option value="WHISKY">
                        <option value="RUM">
                        <option value="J√ÑGERBOMB">
                        <option value="CHAMPAGNE">
                    </datalist>
                </div>
            </div>
            <div class="name-section">
                <div>
                    <label>Nom</label>
                    <input type="text" placeholder="Ex: Bouteille" class="pure-name">
                </div>
                <div>
                    <label>Qt. bouteilles</label>
                    <input type="number" min="1" placeholder="Quantit√©" class="pure-qty">
                </div>
                <div>
                    <label>Prix</label>
                    <input type="number" step="0.01" min="0" placeholder="Prix (‚Ç¨)" class="pure-price">
                </div>
                <div>
                    <label>Max. Entr√©e</label>
                    <input type="text" placeholder="Cliquez pour d√©finir" class="pure-max-entries" readonly>
                </div>
                <div>
                    <label>R√©duc. bouteille suppl.</label>
                    <input type="number" step="0.01" min="0" placeholder="R√©duction (‚Ç¨)" class="pure-discount">
                </div>
                <button type="button" class="pure-duplicate-btn" aria-label="Dupliquer la formule">üìã</button>
                <button type="button" class="pure-delete-btn" aria-label="Supprimer la formule">üóëÔ∏è</button>
            </div>
            <div class="details-section">
                <button type="button" class="add-details-btn" aria-label="Ajouter des d√©tails">+</button>
            </div>
        `;

        this.pureContainer.appendChild(pureDiv);
        this.bindPureEvents(pureDiv);
    }

    bindPureEvents(pureDiv) {
        const duplicateBtn = pureDiv.querySelector('.pure-duplicate-btn');
        duplicateBtn.addEventListener('click', () => this.duplicatePure(duplicateBtn));

        const deleteBtn = pureDiv.querySelector('.pure-delete-btn');
        deleteBtn.addEventListener('click', () => this.deletePure(deleteBtn));

        const addDetailsBtn = pureDiv.querySelector('.add-details-btn');
        addDetailsBtn.addEventListener('click', () => this.addDetails(addDetailsBtn));

        const maxEntriesInput = pureDiv.querySelector('.pure-max-entries');
        maxEntriesInput.addEventListener('click', () => this.showMaxEntriesEditor(maxEntriesInput));
    }

    duplicatePure(button) {
        const originalRow = button.closest('.pure-row');
        const newRow = originalRow.cloneNode(true);
        
        this.bindPureEvents(newRow);
        
        this.pureContainer.appendChild(newRow);
    }

    deletePure(button) {
        const row = button.closest('.pure-row');
        row.remove();
        
        if (this.pureContainer.children.length === 0) {
            this.addPure();
        }
    }

    addDetails(button) {
        const detailsSection = button.parentElement;
        const pureRow = detailsSection.parentElement;
        const nameSection = pureRow.querySelector('.name-section');
        const lastDetailsRow = detailsSection.querySelector('.details-row:last-child') || nameSection;

        const newDetailsRow = document.createElement('div');
        newDetailsRow.className = 'details-row';

        const sourceMaxEntries = lastDetailsRow.querySelector('.pure-max-entries')?.dataset.maxEntries || JSON.stringify({ 1: 1 });

        newDetailsRow.innerHTML = `
            <div>
                <label>Nom</label>
                <input type="text" value="${this.sanitizeInput(lastDetailsRow.querySelector('.pure-name')?.value || '')}" class="pure-name">
            </div>
            <div>
                <label>Qt. bouteilles</label>
                <input type="number" min="1" value="${lastDetailsRow.querySelector('.pure-qty')?.value || ''}" class="pure-qty">
            </div>
            <div>
                <label>Prix</label>
                <input type="number" step="0.01" min="0" value="${lastDetailsRow.querySelector('.pure-price')?.value || ''}" class="pure-price">
            </div>
            <div>
                <label>Max. Entr√©e</label>
                <input type="text" placeholder="Cliquez pour d√©finir" class="pure-max-entries" readonly 
                       data-max-entries='${sourceMaxEntries}'>
            </div>
            <div>
                <label>R√©duc. bouteille suppl.</label>
                <input type="number" step="0.01" min="0" value="${lastDetailsRow.querySelector('.pure-discount')?.value || ''}" class="pure-discount">
            </div>
            <button type="button" class="delete-details-btn" aria-label="Supprimer les d√©tails">üóëÔ∏è</button>
        `;

        detailsSection.insertBefore(newDetailsRow, button);

        const maxEntriesInput = newDetailsRow.querySelector('.pure-max-entries');
        maxEntriesInput.addEventListener('click', () => this.showMaxEntriesEditor(maxEntriesInput));
        
        const deleteBtn = newDetailsRow.querySelector('.delete-details-btn');
        deleteBtn.addEventListener('click', () => this.deleteDetails(deleteBtn));

        const sourceMaxInput = lastDetailsRow.querySelector('.pure-max-entries');
        if (sourceMaxInput && sourceMaxInput.dataset.maxEntries) {
            maxEntriesInput.value = sourceMaxInput.value || 'Cliquez pour d√©finir';
        } else {
            maxEntriesInput.value = '1=1';
        }
    }

    deleteDetails(button) {
        button.closest('.details-row').remove();
    }

    // --- GESTION DE L'√âDITEUR MAX ENTR√âES ---

    showMaxEntriesEditor(input) {
        const oldEditor = document.querySelector('.max-entries-editor');
        if (oldEditor) oldEditor.remove();
       
        const editor = document.createElement('div');
        editor.className = 'max-entries-editor';
       
        editor.innerHTML = `
            <h4>D√©finir Max. Entr√©e par Qt. bouteilles</h4>
            <div class="editor-content">
                <div class="max-entries-inputs"></div>
            </div>
            <div class="editor-footer">
                <button type="button" class="add-max-btn">+ Ajouter</button>
                <button type="button" class="cancel-btn">Annuler</button>
                <button type="button" class="save-max-btn">OK</button>
            </div>
        `;
       
        const inputParent = input.parentElement;
        inputParent.style.position = 'relative';
        inputParent.appendChild(editor);
       
        const inputsContainer = editor.querySelector('.max-entries-inputs');
       
        try {
            const maxEntries = JSON.parse(input.dataset.maxEntries || '{}');
            if (Object.keys(maxEntries).length > 0) {
                for (const [qty, max] of Object.entries(maxEntries)) {
                    this.addMaxEntryInput(inputsContainer, parseInt(qty), max);
                }
            }
        } catch (e) {
            console.error("Donn√©es maxEntries invalides:", e);
        }
       
        if (inputsContainer.children.length === 0) {
            this.addMaxEntryInput(inputsContainer, 1, '');
        }
       
        editor.querySelector('.add-max-btn').addEventListener('click', () => this.addMaxEntryInput(inputsContainer));
        editor.querySelector('.cancel-btn').addEventListener('click', () => editor.remove());
        editor.querySelector('.save-max-btn').addEventListener('click', () => this.saveMaxEntries(editor, input));
    }

    addMaxEntryInput(container, qty = null, max = '') {
        const existingQtys = Array.from(container.querySelectorAll('.max-entry-input'))
            .map(input => parseInt(input.dataset.qty));
        const nextQty = qty ? qty : Math.max(0, ...existingQtys) + 1;
       
        const row = document.createElement('div');
        row.className = 'max-entry-row';
       
        const isFirstRow = nextQty === 1 && container.children.length === 0;
       
        row.innerHTML = `
            <span>${nextQty} bouteille${nextQty > 1 ? 's' : ''}:</span>
            <div class="input-with-delete">
                ${!isFirstRow ? '<button type="button" class="delete-max-btn" title="Supprimer cette ligne">üóëÔ∏è</button>' : ''}
                <input type="number" min="1" class="max-entry-input" data-qty="${nextQty}" value="${max}" placeholder="Entr√©es">
            </div>
        `;
       
        container.appendChild(row);
       
        if (!isFirstRow) {
            const deleteBtn = row.querySelector('.delete-max-btn');
            deleteBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                this.removeMaxEntryInput(row, container);
            });
        }
    }

    removeMaxEntryInput(row, container) {
        if (!row || !container) {
            console.error('Ligne ou conteneur non trouv√©');
            return;
        }
        
        if (container.children.length <= 1) {
            console.log('Impossible de supprimer la derni√®re ligne');
            return;
        }
       
        row.remove();
        
        console.log(`Ligne supprim√©e. Lignes restantes: ${container.children.length}`);
       
        if (container.children.length === 0) {
            this.addMaxEntryInput(container, 1, '');
        }
    }

    saveMaxEntries(editor, targetInput) {
        const inputs = editor.querySelectorAll('.max-entry-input');
        const maxEntries = {};
       
        inputs.forEach(input => {
            const qty = parseInt(input.dataset.qty);
            const max = parseInt(input.value);
            if (!isNaN(qty) && !isNaN(max) && max >= 1) {
                maxEntries[qty] = max;
            }
        });

        try {
            targetInput.dataset.maxEntries = JSON.stringify(maxEntries);
            targetInput.value = Object.entries(maxEntries)
                .map(([qty, max]) => `${qty}=${max}`)
                .join(', ') || 'Cliquez pour d√©finir';
        } catch (e) {
            console.error('Erreur de sauvegarde maxEntries:', e);
            targetInput.value = 'Erreur';
        }
       
        editor.remove();
    }

    // --- DRAG AND DROP ---

    addDragEvents(element) {
        element.addEventListener('dragstart', (e) => this.handleDragStart(e, element));
        element.addEventListener('dragover', (e) => this.handleDragOver(e));
        element.addEventListener('drop', (e) => this.handleDrop(e, element));
        element.addEventListener('dragend', (e) => this.handleDragEnd(e, element));
    }

    handleDragStart(e, element) {
        this.draggedItem = element;
        element.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/html', element.innerHTML);
    }

    handleDragOver(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
    }

    handleDrop(e, element) {
        e.preventDefault();
        
        if (this.draggedItem !== element && this.draggedItem) {
            const container = element.parentElement;
            const allItems = Array.from(container.children).filter(item => 
                !item.classList.contains('access-header-row') && 
                !item.classList.contains('pure-header-row')
            );
            
            const draggedIndex = allItems.indexOf(this.draggedItem);
            const droppedIndex = allItems.indexOf(element);
            
            if (draggedIndex !== -1 && droppedIndex !== -1) {
                const [movedItem] = allItems.splice(draggedIndex, 1);
                allItems.splice(droppedIndex, 0, movedItem);
                
                const header = container.querySelector('.access-header-row, .pure-header-row');
                container.innerHTML = '';
                if (header) container.appendChild(header);
                
                allItems.forEach((item) => {
                    container.appendChild(item);
                    
                    if (item.classList.contains('pure-row')) {
                        this.bindPureEvents(item);
                        this.addDragEvents(item);
                    }
                });
                
                this.attachPrestationEvents();
                this.updateOrderNumbers();
                this.bindSectionToggleEvents();
            }
        }
    }

    handleDragEnd(e, element) {
        element.classList.remove('dragging');
        this.draggedItem = null;
    }

    // --- VALIDATION ---

    validateAccessSoiree() {
        const presentationLow = this.accessPresentationLow;
        const presentationNormal = this.accessPresentationNormal;
        const presentationAlcohol = this.accessPresentationAlcohol;
        const presentationSoft = this.accessPresentationSoft;
        const price = this.accessPrice;

        [presentationLow, presentationNormal, presentationAlcohol, presentationSoft, price]
            .forEach(el => el && el.classList.remove('error'));

        const hasPresentation = presentationLow.value.trim() || 
                               presentationNormal.value.trim() || 
                               presentationAlcohol.value.trim() || 
                               presentationSoft.value.trim();
        const hasPrice = price.value !== '';

        let errors = [];

        if (hasPresentation && !hasPrice) {
            errors.push('Veuillez remplir le champ "Prix" dans "Les entr√©es" si une pr√©sentation est indiqu√©e.');
            price.classList.add('error');
        }

        if (hasPrice && !hasPresentation) {
            errors.push('Veuillez remplir au moins une "Pr√©sentation" dans "Les entr√©es" si un prix est indiqu√©.');
            [presentationLow, presentationNormal, presentationAlcohol, presentationSoft]
                .forEach(el => el.classList.add('error'));
        }

        return { 
            isValid: hasPresentation && hasPrice, 
            errors 
        };
    }

    validatePureSoiree() {
        const pureRows = document.querySelectorAll('.pure-row');
        let errors = [];
        let hasValidRow = false;

        pureRows.forEach((row, index) => {
            const name = row.querySelector('.name-section .pure-name');
            const qty = row.querySelector('.name-section .pure-qty');
            const price = row.querySelector('.name-section .pure-price');
            const maxEntries = row.querySelector('.name-section .pure-max-entries');

            [name, qty, price, maxEntries].forEach(el => el && el.classList.remove('error'));

            const additionalDetails = row.querySelectorAll('.details-section .details-row');
            additionalDetails.forEach(detailRow => {
                detailRow.querySelectorAll('input').forEach(input => input.classList.remove('error'));
            });

            const isRowValid = name.value.trim() && 
                              qty.value && 
                              price.value && 
                              (maxEntries.dataset.maxEntries && maxEntries.dataset.maxEntries !== '{}');

            if (isRowValid) {
                hasValidRow = true;

                additionalDetails.forEach((detailRow, detailIndex) => {
                    const nameDetail = detailRow.querySelector('.pure-name');
                    const qtyDetail = detailRow.querySelector('.pure-qty');
                    const priceDetail = detailRow.querySelector('.pure-price');
                    const maxEntriesDetail = detailRow.querySelector('.pure-max-entries');

                    if (!nameDetail.value.trim()) {
                        errors.push(`Veuillez remplir le champ "Nom" dans la ligne suppl√©mentaire ${detailIndex + 1} de la ligne ${index + 1}.`);
                        nameDetail.classList.add('error');
                    }
                    if (!qtyDetail.value) {
                        errors.push(`Veuillez remplir le champ "Qt. bouteilles" dans la ligne suppl√©mentaire ${detailIndex + 1} de la ligne ${index + 1}.`);
                        qtyDetail.classList.add('error');
                    }
                    if (!priceDetail.value) {
                        errors.push(`Veuillez remplir le champ "Prix" dans la ligne suppl√©mentaire ${detailIndex + 1} de la ligne ${index + 1}.`);
                        priceDetail.classList.add('error');
                    }
                    if (!maxEntriesDetail.dataset.maxEntries || maxEntriesDetail.dataset.maxEntries === '{}') {
                        errors.push(`Veuillez d√©finir "Max. Entr√©e" dans la ligne suppl√©mentaire ${detailIndex + 1} de la ligne ${index + 1}.`);
                        maxEntriesDetail.classList.add('error');
                    }
                });
            } else if (name.value.trim() || qty.value || price.value || 
                      (maxEntries.dataset.maxEntries && maxEntries.dataset.maxEntries !== '{}')) {
                if (!name.value.trim()) {
                    errors.push(`Veuillez remplir le champ "Nom" dans la ligne ${index + 1}.`);
                    name.classList.add('error');
                }
                if (!qty.value) {
                    errors.push(`Veuillez remplir le champ "Qt. bouteilles" dans la ligne ${index + 1}.`);
                    qty.classList.add('error');
                }
                if (!price.value) {
                    errors.push(`Veuillez remplir le champ "Prix" dans la ligne ${index + 1}.`);
                    price.classList.add('error');
                }
                if (!maxEntries.dataset.maxEntries || maxEntries.dataset.maxEntries === '{}') {
                    errors.push(`Veuillez d√©finir "Max. Entr√©e" dans la ligne ${index + 1}.`);
                    maxEntries.classList.add('error');
                }
            }
        });

        return { errors, hasValidRow };
    }

    // --- SAUVEGARDE ---

    async savePrestation() {
    // ‚úÖ UNE SEULE confirmation - utilisation de showCustomConfirm
    const userConfirmed = await this.showCustomConfirm('Souhaitez-vous enregistrer les modifications ?');
    
    if (!userConfirmed) {
        return; // L'utilisateur a cliqu√© sur "Non"
    }

    // R√©cup√©ration des jours s√©lectionn√©s
    const daysCheckboxes = document.querySelectorAll('input[name="days"]:checked');
    const days = Array.from(daysCheckboxes).map(checkbox => checkbox.value);
    
    console.log('Days avant envoi:', days);
    
    let errors = [];

    // Validation des jours
    this.daysCheckboxes.classList.remove('error');
    if (days.length === 0) {
        errors.push('Veuillez s√©lectionner au moins un jour.');
        this.daysCheckboxes.classList.add('error');
    }

    // Validation des sections
    const accessValidation = this.validateAccessSoiree();
    errors = [...errors, ...accessValidation.errors];

    const { errors: pureErrors, hasValidRow: isPureValid } = this.validatePureSoiree();
    errors = [...errors, ...pureErrors];

    if (!accessValidation.isValid && !isPureValid) {
        errors.push('Veuillez remplir au moins une section compl√®te : "Les entr√©es" ou "Les entr√©es avec bouteille".');
    }

    // ‚ùå SUPPRIM√â : Plus de confirm() ici - remplac√© par une alerte simple
    if (errors.length > 0) {
        // Utilisez une alerte styl√©e au lieu de alert()
        this.showMessage(errors.join('\n'), 'error');
        return;
    }

    // Pr√©paration des donn√©es
    const prestation = {
        days,
        presentationLow: this.sanitizeInput(this.accessPresentationLow.value.trim()),
        presentationNormal: this.sanitizeInput(this.accessPresentationNormal.value.trim()),
        presentationAlcohol: this.sanitizeInput(this.accessPresentationAlcohol.value.trim()),
        presentationSoft: this.sanitizeInput(this.accessPresentationSoft.value.trim()),
        price: parseFloat(this.accessPrice.value) || 0,
        sex: this.accessSex.value,
        pureItems: this.buildPureItems()
    };
    
    console.log('Prestation avant envoi:', prestation);

    // Sauvegarde
    let success;
    if (this.editingPrestationId) {
        success = await this.updateData(this.editingPrestationId, prestation);
    } else {
        success = await this.saveData(prestation);
    }

    if (success) {
        this.resetForm();
    }
}

    buildPureItems() {
        if (!document.querySelectorAll('.pure-row').length) {
            return [];
        }

        return Array.from(document.querySelectorAll('.pure-row')).map(row => {
            const category = this.sanitizeInput(row.querySelector('.pure-category-input').value.trim() || '');
            
            const firstDetail = {
                category,
                name: this.sanitizeInput(row.querySelector('.name-section .pure-name').value),
                qty: parseInt(row.querySelector('.name-section .pure-qty').value) || 1,
                price: parseFloat(row.querySelector('.name-section .pure-price').value) || 0,
                maxEntries: this.parseMaxEntries(row.querySelector('.name-section .pure-max-entries')),
                discount: parseFloat(row.querySelector('.name-section .pure-discount').value) || 0
            };

            const additionalDetails = Array.from(row.querySelectorAll('.details-section .details-row')).map(detailRow => ({
                category,
                name: this.sanitizeInput(detailRow.querySelector('.pure-name').value),
                qty: parseInt(detailRow.querySelector('.pure-qty').value) || 1,
                price: parseFloat(detailRow.querySelector('.pure-price').value) || 0,
                maxEntries: this.parseMaxEntries(detailRow.querySelector('.pure-max-entries')),
                discount: parseFloat(detailRow.querySelector('.pure-discount').value) || 0
            }));

            return { details: [firstDetail, ...additionalDetails] };
        }).filter(item => 
            item.details.some(detail => 
                detail.name.trim() && detail.qty && detail.price
            )
        );
    }

    parseMaxEntries(input) {
        try {
            return input.dataset.maxEntries ? JSON.parse(input.dataset.maxEntries) : { 1: 1 };
        } catch (error) {
            console.error('Erreur parsing maxEntries:', error);
            return { 1: 1 };
        }
    }

    // --- AFFICHAGE ---

     renderPrestations() {
        if (this.dashboardContainer) this.dashboardContainer.classList.remove('preview-active');
        if (!this.accessList || !this.pureList) return;

        
        if (this.previewBtn) {
            this.previewBtn.classList.remove('active');
        }
        
        this.isPreviewActive = false;
        
        this.accessList.innerHTML = '';
        this.pureList.innerHTML = '';

        const filteredPrestations = this.selectedDayFilter 
            ? this.prestations.filter(p => p.days && p.days.includes(this.selectedDayFilter)) 
            : [...this.prestations];

        let hasAccess = false;
        let hasPure = false;

        if (filteredPrestations.some(p => this.hasAccessData(p))) {
            hasAccess = true;
            this.accessList.innerHTML = this.getAccessHeaderHtml();
        }

        if (filteredPrestations.some(p => p.pureItems && p.pureItems.length > 0)) {
            hasPure = true;
            this.pureList.innerHTML = this.getPureHeaderHtml();
        }

        filteredPrestations.forEach((prestation, index) => {
            if (this.hasAccessData(prestation)) {
                this.renderAccessPrestation(prestation, index);
            }
            
            if (prestation.pureItems && prestation.pureItems.length > 0) {
                this.renderPurePrestation(prestation, index);
            }
        });

       this.accessList.style.display = hasAccess ? '' : 'none';
¬† ¬† ¬† ¬† this.pureList.style.display = hasPure ? '' : 'none';
        
        if (this.separatorLine) {
            this.separatorLine.style.display = (hasAccess && hasPure) ? 'block' : 'none';
        }

        this.attachPrestationEvents();
        this.updateOrderNumbers();
        this.bindSectionToggleEvents();
    }

 bindSectionToggleEvents() {
    const toggleAccessBtn = document.getElementById('toggle-access-section');
    const togglePureBtn = document.getElementById('toggle-pure-section');

    if (toggleAccessBtn && this.accessList) {
        toggleAccessBtn.addEventListener('click', () => {
            // On bascule la classe sur la fl√®che pour l'animation CSS
            toggleAccessBtn.classList.toggle('expanded');
            // On bascule la classe sur la LISTE des prestations pour les masquer/afficher
            this.accessList.classList.toggle('collapsed');
        });
    }

    if (togglePureBtn && this.pureList) {
        togglePureBtn.addEventListener('click', () => {
            togglePureBtn.classList.toggle('expanded');
            this.pureList.classList.toggle('collapsed');
        });
     }
  }    

    hasAccessData(prestation) {
        return prestation.presentationLow || prestation.presentationNormal || 
               prestation.presentationAlcohol || prestation.presentationSoft || 
               prestation.price;
    }

    getAccessHeaderHtml() {
    return `
        <div class="access-header-row">
            <div class="prestation-label order-label">Ordre:</div>
            <div class="prestation-label">Les entr√©es:</div>
            <div class="prestation-label">Prestation:</div>
            <div class="prestation-label">Prix:</div>
            <div class="prestation-label">Sexe:</div>
            <div class="button-container">
                <span id="toggle-access-section" class="section-toggle-arrow expanded" title="R√©duire/Agrandir la section"></span>
            </div>
        </div>
    `;
}

// Remplacez votre fonction getPureHeaderHtml par celle-ci
getPureHeaderHtml() {
    return `
        <div class="pure-header-row">
            <div class="prestation-label order-label">Ordre:</div>
            <div class="prestation-label">Type:</div>
            <div class="prestation-label">Cat√©gorie:</div>
            <div class="prestation-label">Nom:</div>
            <div class="prestation-label">Qt:</div>
            <div class="prestation-label">Prix:</div>
            <div class="prestation-label">Max. Entr√©e:</div>
            <div class="prestation-label">R√©duc. Suppl.:</div>
            <div class="button-container">
                <span id="toggle-pure-section" class="section-toggle-arrow expanded" title="R√©duire/Agrandir la section"></span>
            </div>
        </div>
    `;
}

    renderAccessPrestation(prestation, index) {
        const accessItem = document.createElement('div');
        accessItem.className = 'prestation-item';
        accessItem.draggable = true;
        accessItem.dataset.index = index;
        
        const visiblePrestations = this.getVisibleAccessPrestations();
        const orderNumber = visiblePrestations.indexOf(prestation) + 1;
        accessItem.dataset.order = orderNumber;

        const presentationRows = [];
        if (prestation.presentationLow) {
            presentationRows.push({ 
                access: 'Heure creuse', 
                prestation: prestation.presentationLow, 
                price: prestation.price, 
                sex: prestation.sex 
            });
        }
        if (prestation.presentationNormal) {
            presentationRows.push({ 
                access: 'Entr√©e sans Boisson', 
                prestation: prestation.presentationNormal, 
                price: prestation.price, 
                sex: prestation.sex 
            });
        }
        if (prestation.presentationAlcohol) {
            presentationRows.push({ 
                access: 'Entr√©e + Alcool', 
                prestation: prestation.presentationAlcohol, 
                price: prestation.price, 
                sex: prestation.sex 
            });
        }
        if (prestation.presentationSoft) {
            presentationRows.push({ 
                access: 'Entr√©e + Soft', 
                prestation: prestation.presentationSoft, 
                price: prestation.price, 
                sex: prestation.sex 
            });
        }

        const detailRows = presentationRows.map((row, rowIndex) => `
            <div class="access-detail-row ${rowIndex % 2 === 0 ? 'even-row' : 'odd-row'}" data-detail-index="${rowIndex}">
                ${rowIndex === 0 ? `<div class="prestation-order">${orderNumber}</div>` : '<div class="prestation-order-empty"></div>'}
                <div class="prestation-value">${this.sanitizeInput(row.access || '-')}</div>
                <div class="prestation-value">${this.sanitizeInput(row.prestation || '-')}</div>
                <div class="prestation-price">${row.price ? `${row.price}‚Ç¨` : '-'}</div>
                <div class="prestation-value prestation-sex">${this.sanitizeInput(row.sex || '-')}</div>
                <div class="button-container">
                    ${rowIndex === 0 ? `
                        <button class="edit-btn" aria-label="√âditer la prestation" data-index="${index}">‚úèÔ∏è</button>
                        <button class="delete-btn" aria-label="Supprimer la prestation" data-index="${index}">üóëÔ∏è</button>
                    ` : ''}
                </div>
            </div>
        `).join('');

        accessItem.innerHTML = detailRows;
        this.accessList.appendChild(accessItem);
        this.addDragEvents(accessItem);
    }

    getVisibleAccessPrestations() {
        const filteredPrestations = this.selectedDayFilter 
            ? this.prestations.filter(p => p.days && p.days.includes(this.selectedDayFilter)) 
            : [...this.prestations];
        
        return filteredPrestations.filter(p => this.hasAccessData(p));
    }

    renderPurePrestation(prestation, index) {
        const visiblePurePrestations = this.getVisiblePurePrestations();
        const globalOrderNumber = visiblePurePrestations.indexOf(prestation) + 1;
        
        let isFirstItemForPrestation = true;
        
        prestation.pureItems.forEach((pure, pureIndex) => {
            const pureItem = document.createElement('div');
            pureItem.className = 'prestation-item pure-item';
            pureItem.draggable = true;
            pureItem.dataset.index = index;
            pureItem.dataset.order = globalOrderNumber;

            const detailRows = pure.details.map((detail, detailIndex) => {
                const maxEntriesText = this.formatMaxEntries(detail.maxEntries);
                const showOrder = isFirstItemForPrestation && detailIndex === 0;
                const showButtons = isFirstItemForPrestation && detailIndex === 0;
                
                const html = `
                    <div class="pure-detail-row ${detailIndex % 2 === 0 ? 'even-row' : 'odd-row'}" data-detail-index="${detailIndex}">
                        ${showOrder ? 
                            `<div class="prestation-order-pure">${globalOrderNumber}</div>` : 
                            '<div class="prestation-order-empty"></div>'}
                        <div class="prestation-label">Entr√©e bouteille:</div>
                        <div class="prestation-value">${this.sanitizeInput(detail.category || 'Aucune')}</div>
                        <div class="prestation-value">${this.sanitizeInput(detail.name || '-')}</div>
                        <div class="prestation-qty">${detail.qty || '-'}</div>
                        <div class="prestation-price">${detail.price ? `${detail.price}‚Ç¨` : '-'}</div>
                        <div class="prestation-max" data-tooltip="${this.sanitizeInput(maxEntriesText)}">${this.sanitizeInput(maxEntriesText)}</div>
                        <div class="prestation-discount">${detail.discount ? `${detail.discount}‚Ç¨` : '-'}</div>
                        <div class="button-container">
                            ${showButtons ? `
                                <button class="edit-btn" aria-label="√âditer la prestation" data-index="${index}">‚úèÔ∏è</button>
                                <button class="delete-btn" aria-label="Supprimer la prestation" data-index="${index}">üóëÔ∏è</button>
                            ` : ''}
                        </div>
                    </div>
                `;
                
                if (showOrder) {
                    isFirstItemForPrestation = false;
                }
                
                return html;
            }).join('');

            pureItem.innerHTML = detailRows;
            this.pureList.appendChild(pureItem);
            this.addDragEvents(pureItem);
        });
    }

    getVisiblePurePrestations() {
        const filteredPrestations = this.selectedDayFilter 
            ? this.prestations.filter(p => p.days && p.days.includes(this.selectedDayFilter)) 
            : [...this.prestations];
        
        return filteredPrestations.filter(p => p.pureItems && p.pureItems.length > 0);
    }

    formatMaxEntries(maxEntries) {
        try {
            return Object.entries(maxEntries || {})
                .map(([qty, max]) => `${qty}=${max}`)
                .join(', ') || '-';
        } catch (error) {
            return '-';
        }
    }

    attachPrestationEvents() {
        document.querySelectorAll('.edit-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const index = parseInt(e.target.dataset.index);
                this.editPrestation(index);
            });
        });

        document.querySelectorAll('.delete-btn').forEach(btn => {
            btn.addEventListener('click', async (e) => {
                const index = parseInt(e.target.dataset.index);
                const confirmed = await this.showCustomConfirm('√ätes-vous s√ªr de vouloir supprimer cette prestation ?');
if (confirmed) {
                    await this.deleteData(index);
                }
            });
        });

        document.querySelectorAll('.prestation-max[data-tooltip]').forEach(element => {
            if (element.scrollWidth > element.clientWidth) {
                element.addEventListener('mouseenter', (e) => this.showTooltip(e, element));
                element.addEventListener('mouseleave', () => this.hideTooltip());
                element.addEventListener('mousemove', (e) => this.positionTooltip(e, element));
            }
        });
    }

    // --- √âDITION ---

    editPrestation(index) {
        const prestation = this.prestations[index];
        if (!prestation) return;

        this.editingPrestationId = prestation.id;

        document.querySelectorAll('input[name="days"]').forEach(checkbox => {
            checkbox.checked = prestation.days && prestation.days.includes(checkbox.value);
        });
        this.accessPresentationLow.value = prestation.presentationLow || '';
        this.accessPresentationNormal.value = prestation.presentationNormal || '';
        this.accessPresentationAlcohol.value = prestation.presentationAlcohol || '';
        this.accessPresentationSoft.value = prestation.presentationSoft || '';
        this.accessPrice.value = prestation.price || '';
        this.accessSex.value = prestation.sex || 'H/F';
        this.pureContainer.innerHTML = '';
        if (prestation.pureItems && prestation.pureItems.length > 0) {
            prestation.pureItems.forEach(pure => {
                this.loadPureItem(pure);
            });
        }
        if (this.pureContainer.children.length === 0) {
            this.addPure();
        }

        this.accessList.style.opacity = '0.5';
        this.pureList.style.opacity = '0.5';
        
        const formElement = document.getElementById('access-form');
        if (formElement) {
            formElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
    }
  
    loadPureItem(pure) {
        const pureDiv = document.createElement('div');
        pureDiv.className = 'pure-row';

        const firstDetail = pure.details[0] || { 
            category: '', 
            name: '', 
            qty: '', 
            price: '', 
            maxEntries: { 1: 1 }, 
            discount: 0 
        };
        const additionalDetails = pure.details.slice(1);

        const maxEntriesText = this.formatMaxEntries(firstDetail.maxEntries);

        pureDiv.innerHTML = `
            <div class="category-section">
                <div>
                    <label>Cat√©gorie de bouteille (optionnel)</label>
                    <input type="text" list="bottle-categories" value="${this.sanitizeInput(firstDetail.category)}" 
                           placeholder="Saisir ou s√©lectionner une cat√©gorie" class="pure-category-input">
                    <datalist id="bottle-categories">
                        <option value="VODKA">
                        <option value="WHISKY">
                        <option value="RUM">
                        <option value="J√ÑGERBOMB">
                        <option value="CHAMPAGNE">
                    </datalist>
                </div>
            </div>
            <div class="name-section">
                <div>
                    <label>Nom</label>
                    <input type="text" value="${this.sanitizeInput(firstDetail.name)}" class="pure-name">
                </div>
                <div>
                    <label>Qt. bouteilles</label>
                    <input type="number" min="1" value="${firstDetail.qty}" class="pure-qty">
                </div>
                <div>
                    <label>Prix</label>
                    <input type="number" step="0.01" min="0" value="${firstDetail.price}" class="pure-price">
                </div>
                <div>
                    <label>Max. Entr√©e</label>
                    <input type="text" value="${maxEntriesText}" class="pure-max-entries" readonly 
                           data-max-entries='${JSON.stringify(firstDetail.maxEntries)}'>
                </div>
                <div>
                    <label>R√©duc. bouteille suppl.</label>
                    <input type="number" step="0.01" min="0" value="${firstDetail.discount}" class="pure-discount">
                </div>
                <button type="button" class="pure-duplicate-btn" aria-label="Dupliquer la formule">üìã</button>
                <button type="button" class="pure-delete-btn" aria-label="Supprimer la formule">üóëÔ∏è</button>
            </div>
            <div class="details-section">
                ${additionalDetails.map(detail => {
                    const detailMaxText = this.formatMaxEntries(detail.maxEntries);
                    return `
                    <div class="details-row">
                        <div>
                            <label>Nom</label>
                            <input type="text" value="${this.sanitizeInput(detail.name)}" class="pure-name">
                        </div>
                        <div>
                            <label>Qt. bouteilles</label>
                            <input type="number" min="1" value="${detail.qty}" class="pure-qty">
                        </div>
                        <div>
                            <label>Prix</label>
                            <input type="number" step="0.01" min="0" value="${detail.price}" class="pure-price">
                        </div>
                        <div>
                            <label>Max. Entr√©e</label>
                            <input type="text" value="${detailMaxText}" class="pure-max-entries" readonly 
                                   data-max-entries='${JSON.stringify(detail.maxEntries)}'>
                        </div>
                        <div>
                            <label>R√©duc. bouteille suppl.</label>
                            <input type="number" step="0.01" min="0" value="${detail.discount}" class="pure-discount">
                        </div>
                        <button type="button" class="delete-details-btn" aria-label="Supprimer les d√©tails">üóëÔ∏è</button>
                    </div>
                `}).join('')}
                <button type="button" class="add-details-btn" aria-label="Ajouter des d√©tails">+</button>
            </div>
        `;

        this.pureContainer.appendChild(pureDiv);
        this.bindPureEvents(pureDiv);

        pureDiv.querySelectorAll('.details-row').forEach(row => {
            const maxInput = row.querySelector('.pure-max-entries');
            const deleteBtn = row.querySelector('.delete-details-btn');
            
            if (maxInput) {
                maxInput.addEventListener('click', () => this.showMaxEntriesEditor(maxInput));
            }
            if (deleteBtn) {
                deleteBtn.addEventListener('click', () => this.deleteDetails(deleteBtn));
            }
        });
    }

     filterByDay(day) {
        if (this.dashboardContainer) this.dashboardContainer.classList.remove('preview-active');
        const buttons = document.querySelectorAll('.day-btn');
        
        buttons.forEach(btn => btn.classList.remove('active'));
        
        if (this.previewBtn) {
            this.previewBtn.classList.remove('active');
        }

        this.selectedDayFilter = (this.selectedDayFilter === day) ? null : day;
        
        if (this.selectedDayFilter) {
            const activeBtn = Array.from(buttons).find(btn => btn.textContent.trim() === day);
            if (activeBtn) {
                activeBtn.classList.add('active');
            }
        }

        this.isPreviewActive = false;
        this.renderPrestations();
    }

    // --- FILTRAGE ET APER√áU ---

    showPreview() {
¬† ¬† ¬† ¬† if (!this.previewSection || !this.dashboardContainer) return; // S√©curit√©

¬† ¬† ¬† ¬† // Ajoute une classe au conteneur principal pour indiquer l'√©tat "Aper√ßu"
¬† ¬† ¬† ¬† this.dashboardContainer.classList.add('preview-active');
¬† ¬† ¬† ¬†
¬† ¬† ¬† ¬† if (this.previewBtn) {
¬† ¬† ¬† ¬† ¬† ¬† this.previewBtn.classList.add('active');
¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† const buttons = document.querySelectorAll('.day-btn');
¬† ¬† ¬† ¬† buttons.forEach(btn => btn.classList.remove('active'));
¬† ¬† ¬† ¬†
¬† ¬† ¬† ¬† this.selectedDayFilter = null;
¬† ¬† ¬† ¬† this.isPreviewActive = true;

¬† ¬† ¬† ¬† this.renderPreviewTable();
¬† ¬† }

    renderPreviewTable() {
        const daysOrder = ['Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi', 'Dimanche'];
        
        let html = `
            <table class="preview-table">
                <tr>
                    <th>Jour</th>
                    <th>Les entr√©es</th>
                    <th>Prestation</th>
                    <th>Cat√©gorie</th>
                    <th>Prix</th>
                    <th>Sexe</th>
                    <th>Qt. bouteilles</th>
                    <th>Max. Entr√©e</th>
                    <th>R√©duc. bouteille suppl.</th>
                </tr>
        `;

        daysOrder.forEach((day) => {
            const dayPrestations = this.prestations.filter(p => p.days && p.days.includes(day));
            const dayClass = `day-${day.toLowerCase()}`;

            if (dayPrestations.length > 0) {
                let allPresentationRows = [];
                let allPureRows = [];

                dayPrestations.forEach((prestation) => {
                    if (prestation.presentationLow) {
                        allPresentationRows.push({
                            access: 'Heure creuse',
                            prestation: prestation.presentationLow,
                            price: prestation.price ? `${prestation.price}‚Ç¨` : '',
                            sex: prestation.sex,
                            category: '', qty: '', maxEntries: '', discount: ''
                        });
                    }
                    if (prestation.presentationNormal) {
                        allPresentationRows.push({
                            access: 'Entr√©e sans Boisson',
                            prestation: prestation.presentationNormal,
                            price: prestation.price ? `${prestation.price}‚Ç¨` : '',
                            sex: prestation.sex,
                            category: '', qty: '', maxEntries: '', discount: ''
                        });
                    }
                    if (prestation.presentationAlcohol) {
                        allPresentationRows.push({
                            access: 'Entr√©e + Alcool',
                            prestation: prestation.presentationAlcohol,
                            price: prestation.price ? `${prestation.price}‚Ç¨` : '',
                            sex: prestation.sex,
                            category: '', qty: '', maxEntries: '', discount: ''
                        });
                    }
                    if (prestation.presentationSoft) {
                        allPresentationRows.push({
                            access: 'Entr√©e + Soft',
                            prestation: prestation.presentationSoft,
                            price: prestation.price ? `${prestation.price}‚Ç¨` : '',
                            sex: prestation.sex,
                            category: '', qty: '', maxEntries: '', discount: ''
                        });
                    }

                    if (prestation.pureItems) {
                        prestation.pureItems.forEach(pure => {
                            pure.details.forEach(detail => {
                                allPureRows.push({
                                    access: 'Bouteille',
                                    prestation: detail.name || '-',
                                    price: detail.price ? `${detail.price}‚Ç¨` : '-',
                                    sex: prestation.sex,
                                    category: detail.category || '',
                                    qty: detail.qty || '-',
                                    maxEntries: this.formatMaxEntries(detail.maxEntries),
                                    discount: detail.discount ? `${detail.discount}‚Ç¨` : ''
                                });
                            });
                        });
                    }
                });

                const rowCount = allPresentationRows.length + allPureRows.length;
                let firstRowOfDay = true;

                [...allPresentationRows, ...allPureRows].forEach(row => {
                    html += `
                        <tr class="${dayClass}">
                            ${firstRowOfDay ? `<td class="day-cell" rowspan="${rowCount}" onclick="gestionEntreesInstance.filterByDay('${day}')">${day}</td>` : ''}
                            <td>${this.sanitizeInput(row.access)}</td>
                            <td>${this.sanitizeInput(row.prestation)}</td>
                            <td>${this.sanitizeInput(row.category)}</td>
                            <td>${row.price}</td>
                            <td>${this.sanitizeInput(row.sex)}</td>
                            <td>${row.qty}</td>
                            <td>${this.sanitizeInput(row.maxEntries)}</td>
                            <td>${row.discount}</td>
                        </tr>
                    `;
                    firstRowOfDay = false;
                });
            } else {
                html += `
                    <tr class="${dayClass}">
                        <td class="day-cell" onclick="gestionEntreesInstance.filterByDay('${day}')">${day}</td>
                        <td colspan="8">Aucune prestation</td>
                    </tr>
                `;
            }
        });

        html += '</table>';
        this.previewSection.innerHTML = html;
    }

    // --- UTILITAIRES ---

    resetForm() {
        document.querySelectorAll('input[name="days"]').forEach(checkbox => {
            checkbox.checked = false;
        });

        this.accessPresentationLow.value = '';
        this.accessPresentationNormal.value = '';
        this.accessPresentationAlcohol.value = '';
        this.accessPresentationSoft.value = '';
        this.accessPrice.value = '';
        this.accessSex.value = 'H/F';

        this.pureContainer.innerHTML = '';
        this.addPure();

        this.editingPrestationId = null; 
        if(this.accessList) this.accessList.style.opacity = '1';
        if(this.pureList) this.pureList.style.opacity = '1';

        document.querySelectorAll('.error').forEach(el => el.classList.remove('error'));
    }

    sanitizeInput(input) {
        const div = document.createElement('div');
        div.textContent = input;
        return div.innerHTML;
    }

    // --- TOOLTIPS ---

    setupTooltips() {
        document.querySelectorAll('.tooltip-icon').forEach(icon => {
            icon.addEventListener('mouseenter', (e) => this.showTooltip(e, icon));
            icon.addEventListener('mouseleave', () => this.hideTooltip());
            icon.addEventListener('mousemove', (e) => this.positionTooltip(e, icon));
        });
    }

    showTooltip(e, element) {
        let tooltip = document.querySelector('.tooltip');
        
        if (!tooltip) {
            tooltip = document.createElement('div');
            tooltip.className = 'tooltip';
            document.body.appendChild(tooltip);
        }

        const tooltipText = element.getAttribute('data-tooltip');
        tooltip.textContent = tooltipText;
        tooltip.classList.add('visible');
        
        this.positionTooltip(e, element);
    }

    hideTooltip() {
        const tooltip = document.querySelector('.tooltip');
        if (tooltip) {
            tooltip.classList.remove('visible');
        }
    }

    positionTooltip(e, element) {
        const tooltip = document.querySelector('.tooltip');
        if (!tooltip || !tooltip.classList.contains('visible')) return;

        const rect = element.getBoundingClientRect();
        const scrollX = window.pageXOffset;
        const scrollY = window.pageYOffset;

        let top = rect.bottom + scrollY + 5;
        let left = rect.left + scrollX + (rect.width / 2) - (tooltip.offsetWidth / 2);

        if (top + tooltip.offsetHeight > window.innerHeight + scrollY) {
            top = rect.top + scrollY - tooltip.offsetHeight - 5;
        }
        
        if (left < scrollX) {
            left = scrollX + 5;
        }
        
        if (left + tooltip.offsetWidth > window.innerWidth + scrollX) {
            left = window.innerWidth + scrollX - tooltip.offsetWidth - 5;
        }

        tooltip.style.top = `${top}px`;
        tooltip.style.left = `${left}px`;
    }

    // --- UI HELPERS ---

    showLoading(show) {
        const container = document.querySelector('.gestion-entrees .container');
        if (container) {
            if (show) {
                container.classList.add('loading');
            } else {
                container.classList.remove('loading');
            }
        }
    }

    showMessage(message, type = 'info') {
        const existingMessages = document.querySelectorAll('.message');
        existingMessages.forEach(msg => msg.remove());

        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${type === 'error' ? 'error-message' : 'success-message'}`;
        messageDiv.textContent = message;
        
        const container = document.querySelector('.gestion-entrees .container');
        if (container) {
            container.insertBefore(messageDiv, container.firstChild);
        }

        setTimeout(() => {
            messageDiv.remove();
        }, 5000);
    }
      showCustomConfirm(message) {
    return new Promise((resolve) => {
        const modalHtml = `
            <div class="unified-confirmation-modal" role="alertdialog" aria-modal="true">
                <div class="modal-content">
                    <p class="modal-message">${message}</p>
                    <div class="modal-buttons">
                        <button class="modal-btn btn-confirm">Oui</button>
                        <button class="modal-btn btn-cancel">Non</button>
                    </div>
                </div>
            </div>
        `;

        // √âviter de cr√©er une modale si une est d√©j√† visible
        if (document.querySelector('.unified-confirmation-modal.show')) {
            return;
        }

        document.body.insertAdjacentHTML('beforeend', modalHtml);
        const modal = document.querySelector('.unified-confirmation-modal:last-child');
        
        requestAnimationFrame(() => {
            modal.classList.add('show');
        });

        const yesBtn = modal.querySelector('.btn-confirm');
        const noBtn = modal.querySelector('.btn-cancel');

        const cleanup = () => {
            document.body.classList.remove('modal-open');
            modal.classList.add('closing');
            modal.addEventListener('animationend', () => {
                 if (modal.parentNode) {
                     modal.parentNode.removeChild(modal);
                 }
            }, { once: true });
        };

        const handleResolve = (value) => {
            // S'assurer qu'on ne r√©sout qu'une seule fois
            if (modal.dataset.resolved) return;
            modal.dataset.resolved = 'true';
            
            document.removeEventListener('keydown', handleKeyDown);
            cleanup();
            resolve(value);
        };

        yesBtn.onclick = () => handleResolve(true);
        noBtn.onclick = () => handleResolve(false);
        
        modal.onclick = (e) => {
            if (e.target === modal) {
                handleResolve(false);
            }
        };

        const handleKeyDown = (e) => {
            if (e.key === 'Escape') {
                handleResolve(false);
            }
        };
        document.addEventListener('keydown', handleKeyDown, { once: true });
        
        document.body.classList.add('modal-open');
    });
}
    
} // Fin de la classe GestionEntrees
