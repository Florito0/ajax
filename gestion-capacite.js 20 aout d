// gestion-capacite.js - Version corrigée pour la réinitialisation

class GestionCapacite {
    constructor(containerId) {
        this.containerId = containerId;
        this.maxCapacity = 100;
        this.currentCount = 0;
        this.schedule = {};
        this.token = localStorage.getItem('token');
        this.apiUrl = '/api/capacite';
        this.discothequeId = null;
        this.userId = null;
        this.autoResetTimer = null;
        this.lastCheckedMinute = null;
    }

    init() {
        this.getUserInfo().then(() => {
            this.loadData();
            this.attachEventListeners();
            this.startFrontendAutoResetCheck(); // ← NOUVEAU
        }).catch(error => {
            console.error('Erreur initialisation:', error);
            this.attachEventListeners();
            this.updateDisplay();
        });
    }

    // Démarrer la vérification côté frontend
    startFrontendAutoResetCheck() {
        console.log('🕐 [FRONTEND] Démarrage vérification auto-reset');
        
        // Vérifier toutes les 30 secondes (plus réactif que le backend)
        this.autoResetTimer = setInterval(() => {
            this.checkFrontendAutoReset();
        }, 30000);
        
        // Vérification immédiate
        this.checkFrontendAutoReset();
    }

    // Vérifier si une réinitialisation est programmée maintenant
    async checkFrontendAutoReset() {
        const now = new Date();
        const currentDay = now.toLocaleDateString('fr-FR', { weekday: 'long' }).toLowerCase();
        const currentTime = now.toTimeString().slice(0, 5); // HH:MM
        const currentMinute = now.getMinutes();
        
        // Éviter les vérifications multiples dans la même minute
        if (this.lastCheckedMinute === currentMinute) return;
        this.lastCheckedMinute = currentMinute;
        
        console.log(`🕐 [FRONTEND] Vérification ${currentDay} ${currentTime}`);
        
        if (this.schedule && this.schedule[currentDay]) {
            const scheduledTime = this.schedule[currentDay];
            
            if (scheduledTime !== 'Désactivé' && scheduledTime === currentTime) {
                console.log('🔄 [FRONTEND] Réinitialisation automatique déclenchée !');
                
                // Afficher une notification
                this.showAutoResetNotification();
                
                // Recharger les données depuis le serveur (au cas où le backend l'aurait déjà fait)
                setTimeout(() => {
                    this.loadData();
                }, 2000);
            }
        }
    }

    // Afficher une notification de réinitialisation automatique
    showAutoResetNotification() {
        this.showAlert('🔄 Réinitialisation automatique en cours...', 'info');
        
        // Animation spéciale pour la réinitialisation auto
        const currentCapacityEl = document.getElementById('current-capacity-display');
        if (currentCapacityEl) {
            currentCapacityEl.style.animation = 'pulse 1s ease-in-out 3 times';
        }
    }

    // Nettoyer les timers lors de la destruction
    destroy() {
        if (this.autoResetTimer) {
            clearInterval(this.autoResetTimer);
            console.log('🕐 [FRONTEND] Timer auto-reset arrêté');
        }
    }

    async getUserInfo() {
        try {
            const response = await fetch('/api/auth/current-user', {
                headers: {
                    'Authorization': `Bearer ${this.token}`
                }
            });
            
            if (response.ok) {
                const data = await response.json();
                this.userId = data.userId;
                this.discothequeId = data.discothequeId;
                console.log('User info loaded:', { userId: this.userId, discothequeId: this.discothequeId });
            } else {
                console.warn('Impossible de récupérer les infos utilisateur');
            }
        } catch (error) {
            console.error('Erreur lors de la récupération des infos utilisateur:', error);
        }
    }

    async loadData() {
        try {
            const response = await fetch(this.apiUrl, {
                headers: {
                    'Authorization': `Bearer ${this.token}`,
                    'Content-Type': 'application/json'
                }
            });
            
            if (response.ok) {
                const data = await response.json();
                if (data && data.length > 0) {
                    const capaciteData = data[0];
                    this.maxCapacity = capaciteData.max || 100;
                    this.currentCount = capaciteData.current || 0;
                    this.schedule = capaciteData.reset_schedule || {};
                    this.updateDisplay();
                    
                    // Charger le planning seulement si on est sur l'interface de planification
                    const autoResetInterface = document.getElementById('capaciteAutoResetInterface');
                    if (autoResetInterface && autoResetInterface.style.display !== 'none') {
                        this.loadSchedule();
                    }
                } else {
                    // Pas de données, utiliser les valeurs par défaut
                    this.updateDisplay();
                }
            } else {
                console.warn('Pas de données de capacité trouvées');
                this.updateDisplay();
            }
        } catch (error) {
            console.error('Erreur lors du chargement des données:', error);
            this.updateDisplay(); // Afficher avec les valeurs par défaut
        }
    }

    async saveData() {
        // Si on n'a pas les IDs nécessaires, on essaye de les récupérer
        if (!this.discothequeId || !this.userId) {
            await this.getUserInfo();
        }

        // Si on n'a toujours pas les IDs, on ne peut pas sauvegarder
        if (!this.discothequeId || !this.userId) {
            console.warn('Impossible de sauvegarder : IDs manquants');
            return false;
        }

        try {
            const response = await fetch(this.apiUrl, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${this.token}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    discotheque_id: this.discothequeId,
                    user_id: this.userId,
                    max: this.maxCapacity,
                    current: this.currentCount,
                    reset_schedule: this.schedule
                })
            });

            if (!response.ok) {
                const error = await response.json();
                console.error('Erreur serveur:', error);
                return false;
            }

            return true;
        } catch (error) {
            console.error('Erreur lors de la sauvegarde:', error);
            return false;
        }
    }

    interpolateColor(color1, color2, factor) {
        const r1 = parseInt(color1.slice(1, 3), 16);
        const g1 = parseInt(color1.slice(3, 5), 16);
        const b1 = parseInt(color1.slice(5, 7), 16);
        const r2 = parseInt(color2.slice(1, 3), 16);
        const g2 = parseInt(color2.slice(3, 5), 16);
        const b2 = parseInt(color2.slice(5, 7), 16);

        const r = Math.round(r1 + (r2 - r1) * factor);
        const g = Math.round(g1 + (g2 - g1) * factor);
        const b = Math.round(b1 + (b2 - b1) * factor);

        return `rgb(${r}, ${g}, ${b})`;
    }

    updateDisplay() {
        const currentCapacityEl = document.getElementById('current-capacity-display');
        const capacityFillEl = document.getElementById('capacity-fill');
        const capacityTextEl = document.getElementById('capacity-text-display');
        const currentInput = document.getElementById('current-count-input');
        const maxInput = document.getElementById('max-capacity-input');
        
        if (currentCapacityEl) currentCapacityEl.textContent = this.currentCount;
        if (currentInput) currentInput.value = this.currentCount;
        if (maxInput) maxInput.value = this.maxCapacity;
        
        const percentage = this.maxCapacity > 0 ? (this.currentCount / this.maxCapacity) * 100 : 0;
        if (capacityFillEl) {
            capacityFillEl.style.width = `${percentage}%`;
            
            const startColor1 = '#9733EE';
            const startColor2 = '#DA22FF';
            const endColor = '#ff4444';
            const factor = this.maxCapacity > 0 ? this.currentCount / this.maxCapacity : 0;
            
            const dynamicEndColor = this.interpolateColor(startColor2, endColor, factor);
            capacityFillEl.style.background = `linear-gradient(to right, ${startColor1}, ${dynamicEndColor})`;
        }
        
        if (capacityTextEl) {
            capacityTextEl.innerHTML = `${this.currentCount} / <span class="max-capacity">${this.maxCapacity}</span>`;
        }
    }

    async updateCount(change) {
        let newCount = this.currentCount + change;
        
        if (newCount < 0) newCount = 0;
        if (newCount > this.maxCapacity) newCount = this.maxCapacity;
        
        this.currentCount = newCount;
        this.updateDisplay();
        
        // Sauvegarde automatique avec debouncing
        clearTimeout(this.saveTimeout);
        this.saveTimeout = setTimeout(() => {
            this.saveData();
        }, 500);
    }

    async updateCapacity() {
        const maxInput = document.getElementById('max-capacity-input');
        const updateBtn = document.getElementById('update-capacity-btn');
        
        this.maxCapacity = parseInt(maxInput.value) || 0;
        if (this.maxCapacity < 0) this.maxCapacity = 0;
        
        if (this.currentCount > this.maxCapacity) {
            this.currentCount = this.maxCapacity;
        }
        
        this.updateDisplay();
        
        const success = await this.saveData();
        
        if (updateBtn) {
            if (success) {
                updateBtn.style.background = 'linear-gradient(to right, #33cc33, #66ff66)';
                setTimeout(() => {
                    updateBtn.style.background = 'linear-gradient(to right, #9733EE, #DA22FF)';
                }, 500);
            } else {
                updateBtn.style.background = 'linear-gradient(to right, #ff4444, #ff6666)';
                setTimeout(() => {
                    updateBtn.style.background = 'linear-gradient(to right, #9733EE, #DA22FF)';
                }, 500);
            }
        }
    }

    // NOUVELLE MÉTHODE : Créer une modale de confirmation dynamique
    // NOUVELLE MÉTHODE : Créer une modale de confirmation avec styling inline
showConfirmation(message) {
    return new Promise((resolve) => {
        console.log('🛡️ [DEBUG] Création de la modale de confirmation');
        
        // Utiliser du styling inline pour éviter les conflits CSS
        const modalHtml = `
            <div style="
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10000;
                font-family: Arial, sans-serif;
            " id="dynamicResetModal">
                <div style="
                    background-color: #2c2c2c;
                    border-radius: 8px;
                    padding: 30px;
                    width: 90%;
                    max-width: 400px;
                    text-align: center;
                    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.8);
                    border: 1px solid #444;
                ">
                    <p style="
                        font-size: 16px;
                        margin-bottom: 25px;
                        color: #ffffff;
                        line-height: 1.4;
                        margin-top: 0;
                    ">${message}</p>
                    <div style="
                        display: flex;
                        justify-content: center;
                        gap: 15px;
                    ">
                        <button id="confirm-yes" style="
                            padding: 12px 25px;
                            border: none;
                            border-radius: 6px;
                            font-size: 14px;
                            font-weight: 600;
                            cursor: pointer;
                            background: linear-gradient(to right, #ff4444, #ff6666);
                            color: white;
                            transition: all 0.2s ease;
                            min-width: 80px;
                        " onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'">Oui</button>
                        <button id="confirm-no" style="
                            padding: 12px 25px;
                            border: none;
                            border-radius: 6px;
                            font-size: 14px;
                            font-weight: 600;
                            cursor: pointer;
                            background: linear-gradient(to right, #666, #888);
                            color: white;
                            transition: all 0.2s ease;
                            min-width: 80px;
                        " onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'">Non</button>
                    </div>
                </div>
            </div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', modalHtml);
        const modal = document.querySelector('#dynamicResetModal');
        
        console.log('🛡️ [DEBUG] Modale ajoutée au DOM');
        
        const yesBtn = modal.querySelector('#confirm-yes');
        const noBtn = modal.querySelector('#confirm-no');
        
        console.log('🛡️ [DEBUG] Boutons trouvés:', yesBtn ? 'Oui ✓' : 'Oui ✗', noBtn ? 'Non ✓' : 'Non ✗');
        
        const cleanup = () => {
            console.log('🛡️ [DEBUG] Nettoyage de la modale');
            if (modal && modal.parentNode) {
                modal.parentNode.removeChild(modal);
            }
        };
        
        if (yesBtn && noBtn) {
            yesBtn.onclick = (e) => {
                e.stopPropagation();
                console.log('🛡️ [DEBUG] Clique Oui – Confirmation de la réinitialisation');
                cleanup();
                resolve(true);
            };
            
            noBtn.onclick = (e) => {
                e.stopPropagation();
                console.log('🛡️ [DEBUG] Clique Non – Annulation');
                cleanup();
                resolve(false);
            };
        } else {
            console.error('🛡️ [ERROR] Boutons non trouvés dans la modale !');
        }
        
        // Fermer en cliquant sur le fond (mais pas sur la modale elle-même)
        modal.onclick = (e) => {
            if (e.target === modal) {
                console.log('🛡️ [DEBUG] Fermeture par clic sur le fond');
                cleanup();
                resolve(false);
            }
        };
        
        // Empêcher la fermeture lors du clic sur la modale interne
        const modalContent = modal.querySelector('div');
        if (modalContent) {
            modalContent.onclick = (e) => {
                e.stopPropagation();
                console.log('🛡️ [DEBUG] Clic sur le contenu de la modale (ne ferme pas)');
            };
        }
    });
}

    // MÉTHODE MODIFIÉE : Gérer la réinitialisation avec confirmation
    async handleReset() {
        console.log('🔄 [DEBUG] Début de handleReset');
        
        // Afficher la confirmation avec le message demandé
        const confirmed = await this.showConfirmation('Êtes-vous sûr de vouloir réinitialiser le nombre de clients actuel à 0 ?');
        
        if (confirmed) {
            console.log('✅ [DEBUG] Confirmation reçue, lancement de resetCount');
            await this.resetCount();
        } else {
            console.log('❌ [DEBUG] Réinitialisation annulée par l\'utilisateur');
        }
    }

    // MÉTHODE CORRIGÉE : Réinitialiser le compteur via l'API
    async resetCount() {
        try {
            console.log('🔄 [DEBUG] Appel API pour réinitialiser le compteur');
            
            const response = await fetch(`${this.apiUrl}/reset`, {
                method: 'PATCH',
                headers: {
                    'Authorization': `Bearer ${this.token}`,
                    'Content-Type': 'application/json'
                }
            });
            
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || 'Erreur lors de la réinitialisation');
            }
            
            const data = await response.json();
            console.log('✅ [DEBUG] Réponse API:', data);
            
            // Mettre à jour l'affichage avec la nouvelle valeur
            this.currentCount = data.data.current; // Devrait être 0
            this.updateDisplay();
            
            // Afficher un message de succès
            this.showAlert('Compteur réinitialisé avec succès!', 'success');
            
        } catch (error) {
            console.error('❌ Erreur lors de la réinitialisation:', error);
            this.showAlert(`Erreur lors de la réinitialisation: ${error.message}`, 'error');
        }
    }

    // NOUVELLE MÉTHODE : Afficher des alertes
    showAlert(message, type = 'info') {
        const alertHtml = `
            <div class="capacite-alert ${type}">
                ${message}
            </div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', alertHtml);
        const alert = document.querySelector('.capacite-alert:last-child');
        
        // Animation d'entrée
        setTimeout(() => {
            alert.classList.add('show');
        }, 10);
        
        // Suppression automatique après 3 secondes
        setTimeout(() => {
            alert.classList.remove('show');
            setTimeout(() => {
                if (alert && alert.parentNode) {
                    alert.parentNode.removeChild(alert);
                }
            }, 300);
        }, 3000);
    }

    showAutoResetInterface() {
        const mainInterface = document.getElementById('capaciteMainInterface');
        const autoResetInterface = document.getElementById('capaciteAutoResetInterface');
        
        if (mainInterface) mainInterface.style.display = 'none';
        if (autoResetInterface) {
            autoResetInterface.style.display = 'block';
            this.renderScheduleDays();
        }
    }

    showMainInterface() {
        const mainInterface = document.getElementById('capaciteMainInterface');
        const autoResetInterface = document.getElementById('capaciteAutoResetInterface');
        
        if (autoResetInterface) autoResetInterface.style.display = 'none';
        if (mainInterface) mainInterface.style.display = 'block';
    }

    renderScheduleDays() {
        const scheduleSection = document.querySelector('#capaciteAutoResetInterface .schedule-section');
        if (!scheduleSection) return;

        const days = ['Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi', 'Dimanche'];
        
        let html = '';
        days.forEach(day => {
            const dayKey = day.toLowerCase();
            const isEnabled = this.schedule[dayKey] && this.schedule[dayKey] !== 'Désactivé';
            const time = isEnabled ? this.schedule[dayKey] : '00:00';
            
            html += `
                <div class="day-schedule">
                    <div class="day-header ${isEnabled ? 'active' : ''}">
                        <input type="checkbox" class="toggle" id="${dayKey}-toggle" ${isEnabled ? 'checked' : ''}>
                        <span class="day-name">${day}</span>
                        <span class="status ${isEnabled ? 'active' : 'inactive'}">${isEnabled ? 'Activé' : 'Désactivé'}</span>
                        <input type="time" class="time-input" value="${time}" ${!isEnabled ? 'disabled' : ''}>
                    </div>
                </div>
            `;
        });

        html += `
            <button class="update-btn" id="save-schedule-btn" data-tooltip="Enregistrer la planification de réinitialisation">
                <i class="fas fa-save"></i> Enregistrer la planification
            </button>
            <button class="back-btn" id="back-to-main-btn">
                <i class="fas fa-arrow-left"></i> Retour à Gestion Capacité
            </button>
        `;

        scheduleSection.innerHTML = html;
        this.attachScheduleListeners();
    }

    attachScheduleListeners() {
        document.querySelectorAll('#capaciteAutoResetInterface .toggle').forEach(toggle => {
            toggle.addEventListener('change', (e) => {
                const dayHeader = e.target.closest('.day-header');
                const timeInput = dayHeader.querySelector('.time-input');
                const status = dayHeader.querySelector('.status');
                
                timeInput.disabled = !e.target.checked;
                dayHeader.classList.toggle('active', e.target.checked);
                
                if (e.target.checked) {
                    status.textContent = 'Activé';
                    status.classList.remove('inactive');
                    status.classList.add('active');
                } else {
                    status.textContent = 'Désactivé';
                    status.classList.remove('active');
                    status.classList.add('inactive');
                    timeInput.value = '00:00';
                }
            });
        });

        const saveBtn = document.getElementById('save-schedule-btn');
        if (saveBtn) {
            saveBtn.addEventListener('click', () => this.saveSchedule());
        }

        const backBtn = document.getElementById('back-to-main-btn');
        if (backBtn) {
            backBtn.addEventListener('click', () => this.showMainInterface());
        }
    }

    loadSchedule() {
        if (!this.schedule || Object.keys(this.schedule).length === 0) return;

        // S'assurer que l'interface de planification est rendue avant de charger
        const autoResetInterface = document.getElementById('capaciteAutoResetInterface');
        if (!autoResetInterface || autoResetInterface.style.display === 'none') return;

        Object.keys(this.schedule).forEach(dayKey => {
            const toggle = document.getElementById(`${dayKey}-toggle`);
            if (!toggle) return; // Si l'élément n'existe pas, on passe
            
            const dayHeader = toggle.closest('.day-header');
            if (!dayHeader) return;
            
            const timeInput = dayHeader.querySelector('.time-input');
            const status = dayHeader.querySelector('.status');
            
            if (toggle && timeInput) {
                const isEnabled = this.schedule[dayKey] && this.schedule[dayKey] !== 'Désactivé';
                toggle.checked = isEnabled;
                timeInput.value = isEnabled ? this.schedule[dayKey] : '00:00';
                timeInput.disabled = !isEnabled;
                
                if (isEnabled) {
                    dayHeader.classList.add('active');
                    if (status) {
                        status.textContent = 'Activé';
                        status.classList.remove('inactive');
                        status.classList.add('active');
                    }
                } else {
                    dayHeader.classList.remove('active');
                    if (status) {
                        status.textContent = 'Désactivé';
                        status.classList.remove('active');
                        status.classList.add('inactive');
                    }
                }
            }
        });
    }

    async saveSchedule() {
        // Demander confirmation avant de sauvegarder
        const confirmed = await this.showConfirmation('Souhaitez-vous enregistrer la planification de réinitialisation automatique ?');
        if (!confirmed) return;

        let hasError = false;
        const newSchedule = {};

        document.querySelectorAll('#capaciteAutoResetInterface .day-schedule').forEach(day => {
            const toggle = day.querySelector('.toggle');
            const timeInput = day.querySelector('.time-input');
            const dayName = day.querySelector('.day-name').textContent;
            const dayKey = dayName.toLowerCase();

            if (toggle.checked && !timeInput.value) {
                hasError = true;
                timeInput.style.border = '1px solid #ff4444';
            } else {
                timeInput.style.border = 'none';
                newSchedule[dayKey] = toggle.checked ? timeInput.value : 'Désactivé';
            }
        });

        if (hasError) {
            this.showAlert('Veuillez spécifier une heure pour tous les jours activés.', 'error');
        } else {
            this.schedule = newSchedule;
            const success = await this.saveData();
            if (success) {
                this.showAlert('Planification enregistrée avec succès !', 'success');
                setTimeout(() => {
                    this.showMainInterface();
                }, 1500);
            } else {
                this.showAlert('Erreur lors de l\'enregistrement. Veuillez réessayer.', 'error');
            }
        }
    }

    // MÉTHODE CORRIGÉE : Attacher les event listeners
    attachEventListeners() {
        // Bouton de mise à jour de capacité
        const updateBtn = document.getElementById('update-capacity-btn');
        if (updateBtn) {
            updateBtn.addEventListener('click', () => this.updateCapacity());
        }

        // Boutons de contrôle +/-
        document.querySelectorAll('.control-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const change = parseInt(e.target.getAttribute('data-change') || e.target.closest('button').getAttribute('data-change'));
                if (change) this.updateCount(change);
            });
        });

        // CORRIGÉ : Bouton de réinitialisation utilise maintenant handleReset
        const resetBtn = document.getElementById('show-reset-modal-btn');
        if (resetBtn) {
            console.log('🔧 [DEBUG] Event listener attaché au bouton de réinitialisation');
            resetBtn.addEventListener('click', (e) => {
                e.preventDefault();
                console.log('🔄 [DEBUG] Clic sur le bouton de réinitialisation');
                this.handleReset();
            });
        } else {
            console.warn('⚠️ [DEBUG] Bouton de réinitialisation non trouvé');
        }

        // Bouton de planification
        const autoResetBtn = document.getElementById('show-auto-reset-btn');
        if (autoResetBtn) {
            autoResetBtn.addEventListener('click', () => this.showAutoResetInterface());
        }
    }
}

// Export pour Node.js/CommonJS
if (typeof module !== 'undefined' && module.exports) {
    module.exports = GestionCapacite;
}
