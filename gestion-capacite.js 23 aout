// gestion-capacite.js - Version compl√®te et corrig√©e

class GestionCapacite {
    constructor(containerId) {
        this.containerId = containerId;
        this.maxCapacity = 100;
        this.currentCount = 0;
        this.schedule = {};
        this.token = localStorage.getItem('token');
        this.apiUrl = '/api/capacite';
        this.discothequeId = null;
        this.userId = null;
        this.autoResetTimer = null;
        this.lastCheckedMinute = null;
        this.lastKnownCount = null;
        this.dataPollingTimer = null;
    }

    init() {
        this.getUserInfo().then(() => {
            this.loadData();
            this.attachEventListeners();
            this.startFrontendAutoResetCheck();
            this.startDataPolling();
        }).catch(error => {
            console.error('Erreur initialisation:', error);
            this.attachEventListeners();
            this.updateDisplay();
        });
    }

    // M√âTHODE MANQUANTE : R√©cup√©rer les informations utilisateur
    async getUserInfo() {
        try {
            const response = await fetch('/api/auth/current-user', {
                headers: {
                    'Authorization': `Bearer ${this.token}`
                }
            });
            
            if (response.ok) {
                const data = await response.json();
                this.userId = data.userId;
                this.discothequeId = data.discothequeId;
                console.log('User info loaded:', { userId: this.userId, discothequeId: this.discothequeId });
            } else {
                console.warn('Impossible de r√©cup√©rer les infos utilisateur');
            }
        } catch (error) {
            console.error('Erreur lors de la r√©cup√©ration des infos utilisateur:', error);
        }
    }

    // NOUVELLE M√âTHODE : Surveillance continue des donn√©es
    startDataPolling() {
        console.log('üîÑ [POLLING] D√©marrage de la surveillance des donn√©es');
        
        // V√©rifier les donn√©es toutes les 10 secondes
        this.dataPollingTimer = setInterval(() => {
            this.checkForDataChanges();
        }, 10000);
    }

    // NOUVELLE M√âTHODE : V√©rifier si les donn√©es ont chang√© c√¥t√© serveur
    async checkForDataChanges() {
        try {
            // Charger les donn√©es sans mettre √† jour l'affichage
            const response = await fetch(this.apiUrl, {
                headers: {
                    'Authorization': `Bearer ${this.token}`,
                    'Content-Type': 'application/json'
                }
            });
            
            if (response.ok) {
                const data = await response.json();
                if (data && data.length > 0) {
                    const serverCurrentCount = data[0].current || 0;
                    
                    // D√©tecter une r√©initialisation automatique
                    if (this.lastKnownCount !== null && 
                        this.lastKnownCount > 0 && 
                        serverCurrentCount === 0) {
                        
                        console.log('üîÑ [POLLING] R√©initialisation automatique d√©tect√©e !');
                        
                        // D√©clencher l'animation de r√©initialisation
                        this.triggerAutoResetAnimation(this.lastKnownCount);
                        
                        // Mettre √† jour les donn√©es locales
                        this.currentCount = serverCurrentCount;
                        this.maxCapacity = data[0].max || this.maxCapacity;
                        this.schedule = data[0].reset_schedule || this.schedule;
                        
                        // Actualiser l'affichage apr√®s l'animation
                        setTimeout(() => {
                            this.updateDisplay();
                        }, 2000);
                    }
                    
                    // Sauvegarder la valeur actuelle pour la prochaine comparaison
                    this.lastKnownCount = serverCurrentCount;
                }
            }
        } catch (error) {
            console.error('‚ùå [POLLING] Erreur lors de la v√©rification des donn√©es:', error);
        }
    }

    // NOUVELLE M√âTHODE : Animation sp√©ciale pour la r√©initialisation automatique
    triggerAutoResetAnimation(previousCount) {
        console.log(`üé¨ [ANIMATION] D√©marrage animation r√©initialisation ${previousCount} ‚Üí 0`);
        
        // Afficher la notification
        this.showAutoResetNotification();
        
        // Animation du compteur qui descend progressivement
        const currentCapacityEl = document.getElementById('current-capacity-display');
        const capacityFillEl = document.getElementById('capacity-fill');
        
        if (currentCapacityEl) {
            let currentDisplayValue = previousCount;
            const step = Math.max(1, Math.floor(previousCount / 20)); // Animation en 20 √©tapes max
            
            const animationInterval = setInterval(() => {
                currentDisplayValue = Math.max(0, currentDisplayValue - step);
                currentCapacityEl.textContent = currentDisplayValue;
                
                // Mettre √† jour la barre de progression
                if (capacityFillEl && this.maxCapacity > 0) {
                    const percentage = (currentDisplayValue / this.maxCapacity) * 100;
                    capacityFillEl.style.width = `${percentage}%`;
                }
                
                // Animation termin√©e
                if (currentDisplayValue <= 0) {
                    clearInterval(animationInterval);
                    currentCapacityEl.textContent = '0';
                    if (capacityFillEl) {
                        capacityFillEl.style.width = '0%';
                    }
                    
                    // Effet de pulsation finale
                    currentCapacityEl.style.animation = 'pulse 0.5s ease-in-out 3';
                    setTimeout(() => {
                        if (currentCapacityEl) {
                            currentCapacityEl.style.animation = '';
                        }
                    }, 1500);
                    
                    console.log('‚úÖ [ANIMATION] Animation de r√©initialisation termin√©e');
                }
            }, 100); // Animation toutes les 100ms
        }
    }    

    // D√©marrer la v√©rification c√¥t√© frontend
    startFrontendAutoResetCheck() {
        console.log('üïê [FRONTEND] D√©marrage v√©rification auto-reset');
        
        // V√©rifier toutes les 30 secondes (plus r√©actif que le backend)
        this.autoResetTimer = setInterval(() => {
            this.checkFrontendAutoReset();
        }, 30000);
        
        // V√©rification imm√©diate
        this.checkFrontendAutoReset();
    }

    // V√©rifier si une r√©initialisation est programm√©e maintenant
    async checkFrontendAutoReset() {
        const now = new Date();
        const currentDay = now.toLocaleDateString('fr-FR', { weekday: 'long' }).toLowerCase();
        const currentTime = now.toTimeString().slice(0, 5); // HH:MM
        const currentMinute = now.getMinutes();
        
        // √âviter les v√©rifications multiples dans la m√™me minute
        if (this.lastCheckedMinute === currentMinute) return;
        this.lastCheckedMinute = currentMinute;
        
        console.log(`üïê [FRONTEND] V√©rification ${currentDay} ${currentTime}`);
        
        if (this.schedule && this.schedule[currentDay]) {
            const scheduledTime = this.schedule[currentDay];
            
            if (scheduledTime !== 'D√©sactiv√©' && scheduledTime === currentTime) {
                console.log('üîÑ [FRONTEND] R√©initialisation automatique d√©clench√©e !');
                
                // Afficher une notification
                this.showAutoResetNotification();
                
                // Recharger les donn√©es depuis le serveur (au cas o√π le backend l'aurait d√©j√† fait)
                setTimeout(() => {
                    this.loadData();
                }, 2000);
            }
        }
    }

    // Afficher une notification de r√©initialisation automatique
    showAutoResetNotification() {
        this.showAlert('üîÑ R√©initialisation automatique en cours...', 'info');
        
        // Animation suppl√©mentaire de l'interface
        const container = document.querySelector('#gestion-capacite .container');
        if (container) {
            container.style.border = '2px solid #3399ff';
            container.style.boxShadow = '0 0 20px rgba(51, 153, 255, 0.5)';
            
            setTimeout(() => {
                container.style.border = '';
                container.style.boxShadow = '0 10px 30px rgba(0, 0, 0, 0.5)';
            }, 3000);
        }
    }

    // M√âTHODE AM√âLIOR√âE : loadData met √† jour lastKnownCount
    async loadData() {
        try {
            const response = await fetch(this.apiUrl, {
                headers: {
                    'Authorization': `Bearer ${this.token}`,
                    'Content-Type': 'application/json'
                }
            });
            
            if (response.ok) {
                const data = await response.json();
                if (data && data.length > 0) {
                    const capaciteData = data[0];
                    this.maxCapacity = capaciteData.max || 100;
                    this.currentCount = capaciteData.current || 0;
                    this.lastKnownCount = this.currentCount; // ‚Üê NOUVEAU : sauvegarder
                    this.schedule = capaciteData.reset_schedule || {};
                    this.updateDisplay();
                    
                    // Charger le planning seulement si on est sur l'interface de planification
                    const autoResetInterface = document.getElementById('capaciteAutoResetInterface');
                    if (autoResetInterface && autoResetInterface.style.display !== 'none') {
                        this.loadSchedule();
                    }
                } else {
                    this.updateDisplay();
                }
            } else {
                console.warn('Pas de donn√©es de capacit√© trouv√©es');
                this.updateDisplay();
            }
        } catch (error) {
            console.error('Erreur lors du chargement des donn√©es:', error);
            this.updateDisplay();
        }
    }

    async saveData() {
        // Si on n'a pas les IDs n√©cessaires, on essaye de les r√©cup√©rer
        if (!this.discothequeId || !this.userId) {
            await this.getUserInfo();
        }

        // Si on n'a toujours pas les IDs, on ne peut pas sauvegarder
        if (!this.discothequeId || !this.userId) {
            console.warn('Impossible de sauvegarder : IDs manquants');
            return false;
        }

        try {
            const response = await fetch(this.apiUrl, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${this.token}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    discotheque_id: this.discothequeId,
                    user_id: this.userId,
                    max: this.maxCapacity,
                    current: this.currentCount,
                    reset_schedule: this.schedule
                })
            });

            if (!response.ok) {
                const error = await response.json();
                console.error('Erreur serveur:', error);
                return false;
            }

            return true;
        } catch (error) {
            console.error('Erreur lors de la sauvegarde:', error);
            return false;
        }
    }

    interpolateColor(color1, color2, factor) {
        const r1 = parseInt(color1.slice(1, 3), 16);
        const g1 = parseInt(color1.slice(3, 5), 16);
        const b1 = parseInt(color1.slice(5, 7), 16);
        const r2 = parseInt(color2.slice(1, 3), 16);
        const g2 = parseInt(color2.slice(3, 5), 16);
        const b2 = parseInt(color2.slice(5, 7), 16);

        const r = Math.round(r1 + (r2 - r1) * factor);
        const g = Math.round(g1 + (g2 - g1) * factor);
        const b = Math.round(b1 + (b2 - b1) * factor);

        return `rgb(${r}, ${g}, ${b})`;
    }

    updateDisplay() {
        const currentCapacityEl = document.getElementById('current-capacity-display');
        const capacityFillEl = document.getElementById('capacity-fill');
        const capacityTextEl = document.getElementById('capacity-text-display');
        const currentInput = document.getElementById('current-count-input');
        const maxInput = document.getElementById('max-capacity-input');
        
        if (currentCapacityEl) currentCapacityEl.textContent = this.currentCount;
        if (currentInput) currentInput.value = this.currentCount;
        if (maxInput) maxInput.value = this.maxCapacity;
        
        const percentage = this.maxCapacity > 0 ? (this.currentCount / this.maxCapacity) * 100 : 0;
        if (capacityFillEl) {
            capacityFillEl.style.width = `${percentage}%`;
            
            const startColor1 = '#9733EE';
            const startColor2 = '#DA22FF';
            const endColor = '#ff4444';
            const factor = this.maxCapacity > 0 ? this.currentCount / this.maxCapacity : 0;
            
            const dynamicEndColor = this.interpolateColor(startColor2, endColor, factor);
            capacityFillEl.style.background = `linear-gradient(to right, ${startColor1}, ${dynamicEndColor})`;
        }
        
        if (capacityTextEl) {
            capacityTextEl.innerHTML = `${this.currentCount} / <span class="max-capacity">${this.maxCapacity}</span>`;
        }
    }

    // M√âTHODE AM√âLIOR√âE : updateCount met √† jour lastKnownCount
    async updateCount(change) {
        let newCount = this.currentCount + change;
        
        if (newCount < 0) newCount = 0;
        if (newCount > this.maxCapacity) newCount = this.maxCapacity;
        
        this.currentCount = newCount;
        this.lastKnownCount = newCount; // ‚Üê NOUVEAU : synchroniser
        this.updateDisplay();
        
        // Sauvegarde automatique avec debouncing
        clearTimeout(this.saveTimeout);
        this.saveTimeout = setTimeout(() => {
            this.saveData();
        }, 500);
    }

    async updateCapacity() {
        const confirmed = await this.showConfirmation('√ätes-vous s√ªr de vouloir modifier la capacit√© d\'accueil ?');

    if (!confirmed) {
        // Si l'utilisateur clique sur "Non" ou ferme la modale, on arr√™te la fonction ici.
        return; 
    }
        const maxInput = document.getElementById('max-capacity-input');
        const updateBtn = document.getElementById('update-capacity-btn');
        
        this.maxCapacity = parseInt(maxInput.value) || 0;
        if (this.maxCapacity < 0) this.maxCapacity = 0;
        
        if (this.currentCount > this.maxCapacity) {
            this.currentCount = this.maxCapacity;
        }
        
        this.updateDisplay();
        
        const success = await this.saveData();
        
        if (updateBtn) {
        if (success) {
            updateBtn.style.background = 'linear-gradient(to right, #33cc33, #66ff66)';
            setTimeout(() => {
                updateBtn.style.background = 'linear-gradient(to right, #9733EE, #DA22FF)';
            }, 500);
            // On peut ajouter une alerte de succ√®s ici si on le souhaite
            this.showAlert('Capacit√© d\'accueil mise √† jour !', 'success');
        } else {
            updateBtn.style.background = 'linear-gradient(to right, #ff4444, #ff6666)';
            setTimeout(() => {
                updateBtn.style.background = 'linear-gradient(to right, #9733EE, #DA22FF)';
            }, 500);
            // On peut ajouter une alerte d'erreur ici si on le souhaite
            this.showAlert('Erreur lors de la mise √† jour.', 'error');
        }
    }
}
    // Cr√©er une modale de confirmation avec styling inline
    showConfirmation(message) {
        return new Promise((resolve) => {
            console.log('üõ°Ô∏è [DEBUG] Cr√©ation de la modale de confirmation');
            
            // Utiliser du styling inline pour √©viter les conflits CSS
            const modalHtml = `
    <div style="
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.6);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    " id="dynamicResetModal">
        <div style="
            background: rgba(25, 25, 25, 0.7);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            padding: 30px;
            width: 90%;
            max-width: 450px;
            text-align: center;
        ">
            <p style="
                font-size: 18px;
                margin-bottom: 25px;
                color: #f0f0f0;
                line-height: 1.5;
                margin-top: 0;
            ">${message}</p>
            <div style="
                display: flex;
                justify-content: center;
                gap: 15px;
            ">
                <button id="confirm-yes" style="
                    /* AJOUT DE !important pour forcer le style */
                    background: linear-gradient(to right, #9733EE, #DA22FF) !important;
                    color: white !important;

                    box-shadow: 0 4px 15px rgba(151, 51, 238, 0.3);
                    padding: 12px 25px;
                    border: none;
                    border-radius: 8px;
                    font-size: 16px;
                    font-weight: 600;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    min-width: 100px;
                " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(151, 51, 238, 0.5)';"
                  onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(151, 51, 238, 0.3)';">Oui</button>
                
                <button id="confirm-no" style="
                    /* AJOUT DE !important pour forcer le style */
                    background: #444 !important;
                    color: white !important;

                    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
                    padding: 12px 25px;
                    border: none;
                    border-radius: 8px;
                    font-size: 16px;
                    font-weight: 600;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    min-width: 100px;
                " onmouseover="this.style.transform='translateY(-2px)'; this.style.background='#555';"
                  onmouseout="this.style.transform='translateY(0)'; this.style.background='#444';">Non</button>
            </div>
        </div>
    </div>
`;
            
            document.body.insertAdjacentHTML('beforeend', modalHtml);
            const modal = document.querySelector('#dynamicResetModal');
            
            console.log('üõ°Ô∏è [DEBUG] Modale ajout√©e au DOM');
            
            const yesBtn = modal.querySelector('#confirm-yes');
            const noBtn = modal.querySelector('#confirm-no');
            
            console.log('üõ°Ô∏è [DEBUG] Boutons trouv√©s:', yesBtn ? 'Oui ‚úì' : 'Oui ‚úó', noBtn ? 'Non ‚úì' : 'Non ‚úó');
            
            const cleanup = () => {
                console.log('üõ°Ô∏è [DEBUG] Nettoyage de la modale');
                if (modal && modal.parentNode) {
                    modal.parentNode.removeChild(modal);
                }
            };
            
            if (yesBtn && noBtn) {
                yesBtn.onclick = (e) => {
                    e.stopPropagation();
                    console.log('üõ°Ô∏è [DEBUG] Clique Oui ‚Äì Confirmation de la r√©initialisation');
                    cleanup();
                    resolve(true);
                };
                
                noBtn.onclick = (e) => {
                    e.stopPropagation();
                    console.log('üõ°Ô∏è [DEBUG] Clique Non ‚Äì Annulation');
                    cleanup();
                    resolve(false);
                };
            } else {
                console.error('üõ°Ô∏è [ERROR] Boutons non trouv√©s dans la modale !');
            }
            
            // Fermer en cliquant sur le fond (mais pas sur la modale elle-m√™me)
            modal.onclick = (e) => {
                if (e.target === modal) {
                    console.log('üõ°Ô∏è [DEBUG] Fermeture par clic sur le fond');
                    cleanup();
                    resolve(false);
                }
            };
            
            // Emp√™cher la fermeture lors du clic sur la modale interne
            const modalContent = modal.querySelector('div');
            if (modalContent) {
                modalContent.onclick = (e) => {
                    e.stopPropagation();
                    console.log('üõ°Ô∏è [DEBUG] Clic sur le contenu de la modale (ne ferme pas)');
                };
            }
        });
    }

    // M√âTHODE MODIFI√âE : G√©rer la r√©initialisation avec confirmation
    async handleReset() {
        console.log('üîÑ [DEBUG] D√©but de handleReset');
        
        // Afficher la confirmation avec le message demand√©
        const confirmed = await this.showConfirmation('√ätes-vous s√ªr de vouloir r√©initialiser le nombre de clients actuel √† 0 ?');
        
        if (confirmed) {
            console.log('‚úÖ [DEBUG] Confirmation re√ßue, lancement de resetCount');
            await this.resetCount();
        } else {
            console.log('‚ùå [DEBUG] R√©initialisation annul√©e par l\'utilisateur');
        }
    }

    // M√âTHODE AM√âLIOR√âE : resetCount met √† jour lastKnownCount
    async resetCount() {
        try {
            console.log('üîÑ [DEBUG] Appel API pour r√©initialiser le compteur');
            
            const response = await fetch(`${this.apiUrl}/reset`, {
                method: 'PATCH',
                headers: {
                    'Authorization': `Bearer ${this.token}`,
                    'Content-Type': 'application/json'
                }
            });
            
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || 'Erreur lors de la r√©initialisation');
            }
            
            const data = await response.json();
            console.log('‚úÖ [DEBUG] R√©ponse API:', data);
            
            // Mettre √† jour l'affichage avec la nouvelle valeur
            this.currentCount = data.data.current;
            this.lastKnownCount = this.currentCount; // ‚Üê NOUVEAU : synchroniser
            this.updateDisplay();
            
            // Afficher un message de succ√®s
            this.showAlert('Compteur r√©initialis√© avec succ√®s!', 'success');
            
        } catch (error) {
            console.error('‚ùå Erreur lors de la r√©initialisation:', error);
            this.showAlert(`Erreur lors de la r√©initialisation: ${error.message}`, 'error');
        }
    }

    // NOUVELLE M√âTHODE : Nettoyer tous les timers
    destroy() {
        if (this.autoResetTimer) {
            clearInterval(this.autoResetTimer);
            console.log('üïê [FRONTEND] Timer auto-reset arr√™t√©');
        }
        
        if (this.dataPollingTimer) {
            clearInterval(this.dataPollingTimer);
            console.log('üîÑ [POLLING] Timer polling arr√™t√©');
        }
        
        if (this.saveTimeout) {
            clearTimeout(this.saveTimeout);
        }
    }

    // Afficher des alertes
    showAlert(message, type = 'info') {
        const alertHtml = `
            <div class="capacite-alert ${type}">
                ${message}
            </div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', alertHtml);
        const alert = document.querySelector('.capacite-alert:last-child');
        
        // Animation d'entr√©e
        setTimeout(() => {
            alert.classList.add('show');
        }, 10);
        
        // Suppression automatique apr√®s 3 secondes
        setTimeout(() => {
            alert.classList.remove('show');
            setTimeout(() => {
                if (alert && alert.parentNode) {
                    alert.parentNode.removeChild(alert);
                }
            }, 300);
        }, 3000);
    }

    showAutoResetInterface() {
        const mainInterface = document.getElementById('capaciteMainInterface');
        const autoResetInterface = document.getElementById('capaciteAutoResetInterface');
        
        if (mainInterface) mainInterface.style.display = 'none';
        if (autoResetInterface) {
            autoResetInterface.style.display = 'block';
            this.renderScheduleDays();
        }
    }

    showMainInterface() {
        const mainInterface = document.getElementById('capaciteMainInterface');
        const autoResetInterface = document.getElementById('capaciteAutoResetInterface');
        
        if (autoResetInterface) autoResetInterface.style.display = 'none';
        if (mainInterface) mainInterface.style.display = 'block';
    }

    renderScheduleDays() {
    const scheduleSection = document.querySelector('#capaciteAutoResetInterface .schedule-section');
    if (!scheduleSection) return;

    const days = ['Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi', 'Dimanche'];
    let html = `
        <div class="schedule-header">
            <h3>Planifier la r√©initialisation automatique</h3>
            <p class="schedule-info">
                <i class="fas fa-info-circle"></i>
                Mode horaire: La r√©initialisation se d√©clenchera √† l'heure pile (ex: 12h00, 13h00, etc.)
            </p>
        </div>
    `;

    days.forEach(day => {
        const dayKey = day.toLowerCase();
        const isEnabled = this.schedule[dayKey] && this.schedule[dayKey] !== 'D√©sactiv√©';
        const time = isEnabled ? this.schedule[dayKey] : '12:00';
        const hourOnly = time.split(':')[0];

        // --- PARTIE MODIFI√âE CI-DESSOUS ---
        html += `
            <div class="day-schedule">
                <div class="day-header ${isEnabled ? 'active' : ''}">
                    <input type="checkbox" class="toggle" id="${dayKey}-toggle" data-day="${dayKey}" ${isEnabled ? 'checked' : ''}>
                    <span class="day-name">${day}</span>
                    <span class="status ${isEnabled ? 'active' : 'inactive'}">${isEnabled ? 'Activ√©' : 'D√©sactiv√©'}</span>
                    <div class="time-selector">
                        <select class="hour-select" data-day="${dayKey}" ${!isEnabled ? 'disabled' : ''}>
                            ${this.generateHourOptions(hourOnly)}
                        </select>
                        </div>
                </div>
            </div>
        `;
        // --- FIN DE LA PARTIE MODIFI√âE ---
    });

    html += `
        <div class="schedule-actions">
            <button class="update-btn" id="save-schedule-btn" data-tooltip="Enregistrer la planification de r√©initialisation">
                <i class="fas fa-save"></i> Enregistrer la planification
            </button>
            <button class="back-btn" id="back-to-main-btn">
                <i class="fas fa-arrow-left"></i> Retour √† Gestion Capacit√©
            </button>
        </div>
    `;

    scheduleSection.innerHTML = html;
    this.attachScheduleListeners();}

// Nouvelle m√©thode pour g√©n√©rer les options d'heures
generateHourOptions(selectedHour = '12') {
    let options = '';
    for (let hour = 0; hour < 24; hour++) {
        // Formate l'heure sur deux chiffres (ex: "09")
        const hourStr = hour.toString().padStart(2, '0');
        
        // Cr√©e le texte √† afficher (ex: "09h00")
        const displayFormat = `${hourStr}h00`; 

        // D√©termine si cette option est s√©lectionn√©e
        const selected = hourStr === selectedHour ? 'selected' : '';
        
        // La 'value' reste "09" mais le texte affich√© est "09h00"
        options += `<option value="${hourStr}" ${selected}>${displayFormat}</option>`;
    }
    return options;
}

// M√©thode modifi√©e pour les event listeners
attachScheduleListeners() {
    document.querySelectorAll('#capaciteAutoResetInterface .toggle').forEach(toggle => {
        toggle.addEventListener('change', (e) => {
            const dayHeader = e.target.closest('.day-header');
            const hourSelect = dayHeader.querySelector('.hour-select');
            const status = dayHeader.querySelector('.status');
            
            hourSelect.disabled = !e.target.checked;
            dayHeader.classList.toggle('active', e.target.checked);
            
            if (e.target.checked) {
                status.textContent = 'Activ√©';
                status.classList.remove('inactive');
                status.classList.add('active');
            } else {
                status.textContent = 'D√©sactiv√©';
                status.classList.remove('active');
                status.classList.add('inactive');
            }
        });
    });

    const saveBtn = document.getElementById('save-schedule-btn');
    if (saveBtn) {
        saveBtn.addEventListener('click', () => this.saveSchedule());
    }

    const backBtn = document.getElementById('back-to-main-btn');
    if (backBtn) {
        backBtn.addEventListener('click', () => this.showMainInterface());
    }
}

// M√©thode modifi√©e pour charger le planning
loadSchedule() {
    if (!this.schedule || Object.keys(this.schedule).length === 0) return;

    const autoResetInterface = document.getElementById('capaciteAutoResetInterface');
    if (!autoResetInterface || autoResetInterface.style.display === 'none') return;

    Object.keys(this.schedule).forEach(dayKey => {
        const toggle = document.getElementById(`${dayKey}-toggle`);
        if (!toggle) return;
        
        const dayHeader = toggle.closest('.day-header');
        if (!dayHeader) return;
        
        const hourSelect = dayHeader.querySelector('.hour-select');
        const status = dayHeader.querySelector('.status');
        
        if (toggle && hourSelect) {
            const isEnabled = this.schedule[dayKey] && this.schedule[dayKey] !== 'D√©sactiv√©';
            toggle.checked = isEnabled;
            hourSelect.disabled = !isEnabled;
            
            if (isEnabled) {
                // Extraire l'heure du format HH:MM
                const hour = this.schedule[dayKey].split(':')[0];
                hourSelect.value = hour;
                
                dayHeader.classList.add('active');
                if (status) {
                    status.textContent = 'Activ√©';
                    status.classList.remove('inactive');
                    status.classList.add('active');
                }
            } else {
                dayHeader.classList.remove('active');
                if (status) {
                    status.textContent = 'D√©sactiv√©';
                    status.classList.remove('active');
                    status.classList.add('inactive');
                }
            }
        }
    });
}

// M√©thode modifi√©e pour sauvegarder
async saveSchedule() {
    const confirmed = await this.showConfirmation('Souhaitez-vous enregistrer la planification de r√©initialisation automatique ?');
    if (!confirmed) return;

    const newSchedule = {};

    document.querySelectorAll('#capaciteAutoResetInterface .day-schedule').forEach(day => {
        const toggle = day.querySelector('.toggle');
        const hourSelect = day.querySelector('.hour-select');
        const dayName = day.querySelector('.day-name').textContent;
        const dayKey = dayName.toLowerCase();

        if (toggle.checked && hourSelect.value !== null) {
            // Format : HH:00 (toujours √† la minute 00)
            newSchedule[dayKey] = `${hourSelect.value}:00`;
        } else {
            newSchedule[dayKey] = 'D√©sactiv√©';
        }
    });

    this.schedule = newSchedule;
    const success = await this.saveData();
    
    if (success) {
        this.showAlert('Planification horaire enregistr√©e avec succ√®s !', 'success');
        setTimeout(() => {
            this.showMainInterface();
        }, 1500);
    } else {
        this.showAlert('Erreur lors de l\'enregistrement. Veuillez r√©essayer.', 'error');
    }
}

    // M√âTHODE CORRIG√âE : Attacher les event listeners
    attachEventListeners() {
        // Bouton de mise √† jour de capacit√©
        const updateBtn = document.getElementById('update-capacity-btn');
        if (updateBtn) {
            updateBtn.addEventListener('click', () => this.updateCapacity());
        }

        // Boutons de contr√¥le +/-
        document.querySelectorAll('.control-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const change = parseInt(e.target.getAttribute('data-change') || e.target.closest('button').getAttribute('data-change'));
                if (change) this.updateCount(change);
            });
        });

        // CORRIG√â : Bouton de r√©initialisation utilise maintenant handleReset
        const resetBtn = document.getElementById('show-reset-modal-btn');
        if (resetBtn) {
            console.log('üîß [DEBUG] Event listener attach√© au bouton de r√©initialisation');
            resetBtn.addEventListener('click', (e) => {
                e.preventDefault();
                console.log('üîÑ [DEBUG] Clic sur le bouton de r√©initialisation');
                this.handleReset();
            });
        } else {
            console.warn('‚ö†Ô∏è [DEBUG] Bouton de r√©initialisation non trouv√©');
        }

        // Bouton de planification
        const autoResetBtn = document.getElementById('show-auto-reset-btn');
        if (autoResetBtn) {
            autoResetBtn.addEventListener('click', () => this.showAutoResetInterface());
        }
    }
}

// Export pour Node.js/CommonJS
if (typeof module !== 'undefined' && module.exports) {
    module.exports = GestionCapacite;
}
